{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"Introducing XComponent AppControl"},{"location":"#focused-on-what-really-mattersyour-applications","title":"Focused on What Really Matters\u2014Your Applications","text":"<p>For small and mid-sized enterprises, the performance and availability of your applications are critical to your business success. That\u2019s why AppControl is designed to minimize downtime by enabling fast, automated responses to incidents directly within your applications\u2014whether they are legacy systems or modern cloud-based apps. Unlike many solutions, AppControl integrates without requiring any modifications to your existing applications, ensuring a smooth deployment without risking your critical systems.  While many traditional monitoring solutions focus primarily on servers, networks, and infrastructure, AppControl takes a different approach. We follow the lifeblood of your business: your applications. Whether it's restarting services, executing custom tasks, or applying real-time fixes, AppControl gives you the power to keep your applications running smoothly\u2014without the complexity and overhead of traditional tools that often require a full infrastructure overhaul.</p> <p></p>"},{"location":"#what-makes-appcontrol-different-from-other-solutions","title":"What Makes AppControl Different from Other Solutions","text":"<ul> <li>No modifications required: Unlike other tools, AppControl integrates directly with your existing applications, whether legacy or cloud-based, without needing any changes to their structure.</li> <li>Application-Centric Approach: While many competing solutions focus on infrastructure (servers, networks), AppControl is designed specifically to monitor, manage, and automate your applications, which are the core of your business.</li> <li>Hybrid Environment Management: Whether you operate on-premise systems or in the cloud, AppControl provides seamless integration and centralized management for applications across complex environments.</li> <li>Real-time automation: With AppControl, responses to incidents are automated and intelligent, eliminating human error and reducing downtime.</li> <li>Ease of Use: Unlike traditional tools, no complex setup is required. AppControl is easy to install, use, and scale with your growing needs.</li> <li>Target audience: AppControl is ideal for small and mid-sized enterprises looking for an application management solution without the complexity of large-scale orchestration tools.</li> </ul>"},{"location":"#key-benefits-of-appcontrol","title":"Key Benefits of AppControl","text":"<ul> <li>Application-Centric: Focus on what matters most\u2014your applications, not the underlying infrastructure.</li> <li>Automated Responses: Automates incident responses for both legacy and cloud-native applications.</li> <li>No Modifications Required: Integrate your existing systems without any changes.</li> <li>Real-Time Control: Act instantly when issues arise, minimizing impact on your business.</li> <li>Ease of Deployment: Simple installation with quick configuration and minimal effort.</li> <li>Scalable: Adapts to the needs of your business as it grows.</li> </ul>"},{"location":"#appcontrol-and-itil-bridging-the-gap-between-teams","title":"AppControl and ITIL: Bridging the Gap Between Teams","text":"<p>In modern IT organizations, incident and problem management require seamless collaboration across Operations, Development, Support, and Business teams. AppControl enhances ITIL practices by automatically linking incidents to affected application components, reducing diagnostic time, and improving cross-team communication. Unlike traditional monitoring tools, AppControl provides a unified view of applications to accelerate incident resolution and foster continuous improvement, making it a key complement to ITSM solutions.</p>"},{"location":"#why-choose-appcontrol","title":"Why Choose AppControl?","text":"<p>AppControl is specifically designed for businesses that:</p> <ul> <li>Operate in hybrid environments and want to modernize their systems without altering their existing infrastructure.</li> <li>Don\u2019t need the complexity of traditional infrastructure-focused solutions and are looking for a simple, effective, application-centric management tool.</li> <li>Prioritize application availability and performance over focusing solely on infrastructure.</li> </ul> <p>With AppControl, you\u2019re not just notified of issues\u2014you\u2019re equipped to solve them, ensuring the continuous operation of your critical applications and minimizing the impact of disruptions on your business. It\u2019s the ideal solution for companies that want to modernize without compromise and focus on what truly matters: their applications.</p> <p>Ready to take control of your application reliability? Request a demo or Start a free trial today.</p>"},{"location":"agentazure/","title":"Gateways and Agents Installation in Azure","text":""},{"location":"agentazure/#docker-image-for-gateway-agent-and-azure-cli-deployment-in-azure","title":"Docker Image for Gateway, Agent, and Azure CLI Deployment in Azure","text":"<p>To simplify the deployment of AppControl\u2019s gateway and agent in Azure, a pre-configured Docker image is available. This image includes:</p> <ul> <li>AppControl Gateway</li> <li>AppControl Agent</li> <li>Azure CLI (az cli)</li> </ul> <p>The goal is to streamline the process of deploying and managing the agent and gateway in an Azure environment. By running this Docker container in Managed Identity, the agent will have the capability to execute Azure CLI commands without requiring additional authentication.</p> <p>Key Benefits</p> <ul> <li> <p>Pre-configured Environment: The Docker image includes both the gateway and the agent, along with the Azure CLI, in one cohesive package. This eliminates the need to install and configure each component separately.</p> </li> <li> <p>Managed Identity Integration: When the Docker container is run with a managed identity, the agent gains access to Azure resources without manual authentication. This allows the agent to execute az commands securely, inheriting the permissions associated with the managed identity.</p> </li> <li> <p>Seamless Deployment: This image is designed to be used within Azure environments, simplifying the process of deploying the gateway and agent directly in the cloud. You can use the image to monitor and manage your applications and infrastructure easily.</p> </li> </ul>"},{"location":"agentazure/#deploying-an-azure-container-with-a-managed-identity-using-appcontrols-docker-image","title":"Deploying an Azure Container with a Managed Identity Using AppControl\u2019s Docker Image","text":"<p>This guide will walk you through creating a dedicated resource group, setting up a managed identity, and running a container using AppControl's Docker image, which includes the gateway, agent, and Azure CLI.</p> <p>Prerequisites</p> <ul> <li>Azure CLI installed on your local machine.</li> <li>Azure account with sufficient privileges to create resource groups, managed identities, and run containers.</li> </ul> <p>Procedure</p>"},{"location":"agentazure/#1-create-a-resource-group","title":"1. Create a Resource Group","text":"<p>First, create a new resource group in Azure. This resource group will house the container and the associated resources.</p> <pre><code>az group create --name AppControlResourceGroup --location &lt;your-region&gt;\n</code></pre> <p>Replace  with the desired Azure region (e.g., eastus, westus, westeurope)."},{"location":"agentazure/#2-create-a-managed-identity","title":"2. Create a Managed Identity","text":"<p>Next, create a managed identity that will be used by the container to authenticate and execute Azure commands without requiring credentials.</p> <pre><code>az identity create --name AppControlIdentity --resource-group AppControlResourceGroup --location &lt;your-region&gt;\n</code></pre> <p>Once the managed identity is created, note down the client ID and principal ID (also referred to as the object ID) from the output.</p>"},{"location":"agentazure/#3-assign-the-managed-identity-to-a-role","title":"3. Assign the Managed Identity to a Role","text":"<p>Assign the managed identity appropriate roles so that it has permissions to interact with Azure resources. For example, to allow it to manage virtual machines, assign the Virtual Machine Contributor role.</p> <pre><code>az role assignment create --assignee &lt;principal-id&gt; --role \"Virtual Machine Contributor\" --scope /subscriptions/&lt;subscription-id&gt;/resourceGroups/AppControlResourceGroup\n</code></pre> <p>Replace:</p> <ul> <li> with the principal ID of the managed identity. <li> with your Azure subscription ID.     You can also assign different roles depending on what permissions are needed for the agent running in the container."},{"location":"agentazure/#4-create-and-configure-an-azure-container-instance","title":"4. Create and Configure an Azure Container Instance","text":"<p>Now, deploy an Azure Container Instance using the Docker image that contains the AppControl gateway, agent, and Azure CLI. Make sure to assign the managed identity to this container so it can execute Azure commands without requiring explicit credentials.</p> <pre><code>az container create \\\n  --resource-group AppControlResourceGroup \\\n  --name appcontrol-container \\\n  --image xcomponent/x4b-azuregateway:latest \\\n  --assign-identity &lt;client-id&gt; \\\n  --cpu 1 \\\n  --memory 1.5 \\\n  --environment-variables AZURE_CLIENT_ID=&lt;client-id&gt; \\\n  --location &lt;your-region&gt; \\\n  --dns-name-label appcontrol-container-instance \\\n  --resource-group [**RESOURCE-GROUP-NAME**] \\\n   --restart-policy OnFailure \\\n   --environment-variables  AZURE_CLIENT_ID=&lt;client-id&gt; X4B_ACCESS_KEY=[**YOUR-GATEWAY-ACCESS-KEY**] X4B_SECRET_ACCESS_KEY=[**YOUR-GATEWAY-SECRET-KEY**] X4B_PROXY_NAME=[**YOUR-GATEWAY-NAME**] APPCONTROL_API_URL=https://appcontrol.xcomponent.com/core/\n</code></pre> <p>Replace:</p> <ul> <li> with the client ID of the managed identity. <li> with your preferred Azure region. <p>This command will:</p> <p>Create a new container instance running the Docker image xcomponent/x4b-azuregateway:latest. Assign the managed identity to the container so that it can run Azure CLI commands using the permissions of that identity. Allocate 1 CPU and 1.5GB memory for the container.</p>"},{"location":"agentazure/#5-verify-the-container-and-managed-identity","title":"5. Verify the Container and Managed Identity","text":"<p>After running the above command, you can verify that the container is running:</p> <pre><code>az container show --resource-group AppControlResourceGroup --name appcontrol-container --query \"instanceView.state\"\n</code></pre> <p>If everything is configured correctly, the container will be in a \"Running\" state.</p>"},{"location":"agentazure/#6-running-azure-cli-commands-from-inside-the-container","title":"6. Running Azure CLI Commands from Inside the Container","text":"<p>Since the container is running with the managed identity, you can now use the Azure CLI inside the container to manage Azure resources. The managed identity provides seamless access without needing explicit authentication credentials.</p> <p>To list virtual machines, for example, you can run the following command inside the container:</p> <pre><code>az vm list --output table\n</code></pre> <p>The managed identity will use the permissions assigned to it to interact with the Azure resources as needed.</p>"},{"location":"agentazure/#7-clean-up-resources-optional","title":"7. Clean Up Resources (Optional)","text":"<p>Once you're done with the container and managed identity, you can delete the resource group and all its associated resources:</p> <pre><code>az group delete --name AppControlResourceGroup --yes --no-wait\n</code></pre> <p>This command will remove the resource group, the container, and the managed identity.</p>"},{"location":"agentazure/#conclusion","title":"Conclusion","text":"<p>By following this procedure, you can deploy a container running AppControl\u2019s gateway, agent, and Azure CLI in an Azure environment, using a managed identity for secure, password-less authentication. This setup allows the agent to execute Azure commands seamlessly, simplifying infrastructure management and monitoring.</p> <p>For more advanced configurations or additional details, refer to the official Azure and AppControl documentation.</p> <p>After the container is created and starts automatically, check its operation in Azure by examining the logs.</p> <p>Now check on AppControl to ensure the gateway is accessible.</p> <p></p> <p>You are now ready to create your map in AppControl, utilizing this gateway and agent to monitor your Azure infrastructure.</p> <p>Below is an example that supervises an Azure Function:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?&gt;\n&lt;apps&gt;\n &lt;hosts&gt;\n  &lt;host hostid=\"agent-azure\" host=\"localhost\" port=\"12567\" sslprotocol=\"Tls12\" /&gt;\n &lt;/hosts&gt;\n &lt;auths&gt;\n  &lt;auth authid=\"LOCAL\" domain=\"\" password=\"\" user=\"\" /&gt;\n &lt;/auths&gt;\n &lt;app name=\"AZURE MAP\" version=\"v1\"&gt;\n  &lt;component name=\"Azure CLI\" description=\"Azure access\" hostref=\"agent-azure\" authref=\"LOCAL\" redirectoutput=\"false\" type=\"file\"&gt;\n   &lt;action value=\"az version\" name=\"check\" /&gt;\n   &lt;action value=\"az $(command)\" commandname=\"Test az cli\" name=\"custom\"&gt;\n    &lt;parameters&gt;\n     &lt;parameter name=\"command\" value=\"account list\" canedit=\"true\" validation=\"\\*\" /&gt;\n    &lt;/parameters&gt;\n   &lt;/action&gt;\n  &lt;/component&gt;\n  &lt;component name=\"AzureFunction\" description=\"Azure Function\" hostref=\"agent-azure\" authref=\"LOCAL\" redirectoutput=\"true\" type=\"browser\"&gt;\n   &lt;father&gt;Azure&lt;/father&gt;\n   &lt;action value=\"az functionapp show --ids /subscriptions/[SUBSCRIPTION-ID]/resourceGroups/[RESOURCE-GROUP-NAME]/providers/Microsoft.Web/sites/[FUNCTION-APP-NAME] --query 'state' | grep -q '&amp;#34;Running&amp;#34;'\" name=\"check\" /&gt;\n   &lt;action value=\"az functionapp start --ids /subscriptions/[SUBSCRIPTION-ID]/resourceGroups/[RESOURCE-GROUP-NAME]/providers/Microsoft.Web/sites/[FUNCTION-APP-NAME]\" name=\"enable\" /&gt;\n   &lt;action value=\"az functionapp stop --ids /subscriptions/[SUBSCRIPTION-ID]/resourceGroups/[RESOURCE-GROUP-NAME]/providers/Microsoft.Web/sites/[FUNCTION-APP-NAME]\" name=\"disable\" /&gt;\n  &lt;/component&gt;\n &lt;/app&gt;\n&lt;/apps&gt;\n</code></pre>"},{"location":"agents/","title":"Agent installation","text":"<p>An AppControl Agent is a key component that enables communication between your infrastructure and the AppControl gateway. It is responsible for executing commands, checking the status of components, and relaying important information to ensure smooth operation and monitoring of your applications.</p> <p>The agent is designed to be cross-platform, meaning it can be deployed on both Linux and Windows systems, offering flexibility across diverse environments. Furthermore, it is optimized to be lightweight, consuming minimal CPU and memory resources. This ensures that the agent runs efficiently in the background without impacting the performance of the host system.</p> <p>With a simple installation process and low resource footprint, AppControl Agents are an essential part of managing your applications, regardless of the platform or scale.</p>"},{"location":"agents/#latest-available-versions","title":"Latest Available versions","text":"Operating System Version Format Latest version Microsoft Windows 32 bits All Versions zip Windows Agent32 Zip Microsoft Windows 64 bits All Versions zip Windows Agent64 Zip Alpine 3.18.3 tar.gz Alpine tar.gz Alma Linux (EL) 8.8 (Compatibility with RedHat 8) tar.gz Alma8 tar.gz Alma Linux (EL) 9.2 (Compatibility with RedHat 9) tar.gz Alma9 tar.gz Rocky Linux (EL) 8.8 (Compatibility with RedHat 8) tar.gz Rocky8 Linux Rocky Linux (EL) 9.2 (Compatibility with RedHat 9) tar.gz Rocky9 Linux Debian 11.7 tar.gz Debian11 tar.gz Debian 12.1 tar.gz Debian12 tar.gz Alpine alpine:3.18.3 docker docker pull xcomponent/appcontrol-agent:latest-alpine Alma Linux (EL) almalinux:8.8-minimal (Compatibility with RedHat 8) docker docker pull xcomponent/appcontrol-agent:latest-almalinux Alma Linux (EL) almalinux:9.2-minimal (Compatibility with RedHat 9) docker docker pull xcomponent/appcontrol-agent:latest-almalinux Debian debian:11.5-slim docker docker pull xcomponent/appcontrol-agent:latest-debian Rocky Linux (EL) rockylinux:8.8-minimal (Compatibility with RedHat 8) docker docker pull xcomponent/appcontrol-agent:latest-rockylinux Rocky Linux (EL) almalinux:9.2-minimal (Compatibility with RedHat 9) docker docker pull xcomponent/appcontrol-agent:latest-rockylinux <p>All binary versions are listed here: All binaries versions</p> <p>All docker versions are listed here: All docker versions</p>"},{"location":"agents/#microsoft-windows-platform","title":"Microsoft Windows Platform","text":"<p>Note:</p> <pre><code>We recommand to use cmd.exe as a shell to install the agent. We don't offer the support for installation through powershell.\n</code></pre> <p>To install XComponent AppControl Agent under Windows OS, unzip the following file into an installation directory. The configuration file ( config.dat ) is located in the same directory. Refer to the agent configuration section to customize the configuration. You have 2 options:</p> <ul> <li>Install an run the agent as a Microsoft Windows Service</li> <li>Run the agent in interactive mode (in a cmd.exe)</li> </ul>"},{"location":"agents/#option-1-install-and-start-the-agent-as-a-microsoft-windows-service","title":"Option 1. Install and start the agent as a Microsoft Windows Service","text":"<ul> <li>To register the program in the service registry of the Microsoft\ufffd Windows machine execute the following command in a prompt (cmd.exe) with administrative permissions:</li> </ul> <pre><code>C:\\appcontrol&gt;xcAgent --install --servicename XComponentAppControlAgent\nXComponent App Control Agent, version 9.9\nCopyright \u00a9 Invivoo Software 2022\nXComponent AppControl service name: XComponentAppControlAgentXComponent AppControl service display name: XComponent AppControl AgentXComponentAppControlAgent is installed.\n</code></pre> <ul> <li>We can either specify the display service name during registration:</li> </ul> <pre><code>C:\\appcontrol&gt;xcAgent.exe --install --servicename appcontrolagent --servicedisplayname \"Agent AppControl\"\nXComponent App Control Agent, version 9.9\nCopyright \u00a9 Invivoo Software 2022\nXComponent App Control service name: appcontrolagent\nXComponent App Control service display name: Agent AppControl\nappcontrolagent is installed.\n</code></pre> <ul> <li>Uninstalling the agent can be done also with the following command line:</li> </ul> <pre><code>C:\\appcontrol&gt;xcAgent.exe --uninstall --servicename appcontrolagent\nXComponent App Control Agent, version 9.9\nCopyright \u00a9 Invivoo Software 2022\nappcontrolagent has been uninstalled.\n</code></pre> <ul> <li>Start the service XComponent AppControl Agent</li> </ul>"},{"location":"agents/#option-2-run-the-agent-in-interactive-mode-from-a-prompt-cmdexe","title":"Option 2. Run the agent in interactive mode from a prompt (cmd.exe)","text":"<p>Run cmd.exe and then go to the agent folder.</p> <pre><code>C:\\appcontrol&gt;xcAgent.exe --console\nXComponent AppControl Agent, version 7.0.0-R1\nCopyright \u00a9 Invivoo Software 2022\n\n</code></pre>"},{"location":"agents/#adding-a-microsoft-windows-firewall-port-rule-optional-step","title":"Adding a Microsoft Windows firewall port rule (optional step)","text":"<p>If you need to communicate with the agent from another computer, you should need to create a firewall rule to open the agent's port.</p> <p>In this case the agent's port is 12567, the command above creates the correct rule on the firewall.</p> <p>Run cmd.exe (with Administrative permissions) and then execute the following command.</p> <pre><code>C:\\&gt;netsh advfirewall firewall add rule name=\"AppControl-AgentRule\" dir=in action=allow protocol=TCP localport=12567\n\n</code></pre> <p>You can check that the rule is correctly created with this command:</p> <pre><code>C:\\&gt;netsh advfirewall firewall show rule name=\"AppControl-AgentRule\"\n</code></pre> <p>Please refer to the following link to check if the agent port is reachable.</p> <p>Note:</p> <pre><code>If you are using another firewall or and anti-virus, you should refer to the corresponding documentation.\n</code></pre>"},{"location":"agents/#enterprise-linux","title":"Enterprise Linux","text":"<p>At the moment EL versions of XComponent AppControl Agent are Rocky Linux and Alma Linux.</p> <p>To install XComponent AppControl Agent under EL, untar the following Alma tar.gz into an installation directory (Tarball file). The configuration file ( config.dat ) is located in the same directory. Refer to the agent configuration section to customize the configuration.</p> <p>Replace /home/xc/xcagent with your own installation folder.</p> <pre><code>/home/xc/xcagent $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/xc/xcagent/libs\n/home/xc/xcagent $ ./xcAgent.bin --file /home/xc/xcagent/config.dat\n\nXComponent AppControl Agent, version 7.0.0-R1\nCopyright \ufffd Invivoo Software 2022\n\n</code></pre>"},{"location":"agents/#agentless-linux-unix","title":"Agentless Linux &amp; Unix","text":"<p>From an XComponent AppControl Linux agent, you can enable AgentLess mode via SSH2. This mode allows a Linux XComponent AppControl Agent to forward actions provided by the AppControl server under a non permanent Ssh channel to the IP address and account configured in the agent configuration file. Refer to the agent configuration section to customize the configuration.</p>"},{"location":"agents/#docker-installation","title":"Docker Installation","text":"<p>The docker image of the agent is available here on docker hub.</p> <p>You can pull the docker image using the following command line:</p> <pre><code>root $ docker pull xcomponent/appcontrol-agent:latest\n</code></pre> <p>Environment variables exposed by the docker image are the following:</p> Variable Description CONFIG_FILE_PATH Path to the config.dat TRUSTED_SERVERS List of IP addresses, or Dns names of XComponent AppControl servers authorized to contact the agent (Can be empty) LOG_LEVEL Log levels ('NONE', 'ERROR', 'INFO', 'TRACE') PORT Default value: 12567. Port used as the agent's TCP listening port. Numerical format. NB_DAYS_TO_DELETE_LOGS Default value: 0. Retention period for trace files archived under logdirectory /logs-backup/ (In number of days) LOG_STANDARD_OUTPUT Default value: true. Boolean value (true or false). If true redirect all the logs to std output <p>Some Technicals Points:</p> <ol> <li>If your agent needs to access to local resources (eg: scripts), you have 2 ways to achieve this:<ul> <li>Inherits from this docker image and create your own image</li> <li>Or you can map a directory to the docker image</li> </ul> </li> </ol> <p>Running the docker image:</p> <pre><code>root $ docker run -p 12567:12567 xcomponent/appcontrol-agent:latest\n</code></pre>"},{"location":"agents/#agent-configuration","title":"Agent Configuration","text":"<p>The default configuration file is name config.dat. It's located near the XComponent AppControl Agent configuration file.</p> <pre><code>&lt;config&gt;\n  &lt;item key=\"networkAddress\"     value=\"127.0.0.1\" /&gt;\n  &lt;item key=\"port\"               value=\"12567\" /&gt;\n  &lt;item key=\"checktimeout\"       value=\"20\" /&gt;\n  &lt;item key=\"logdirectory\"       value=\"log\" /&gt;\n  &lt;item key=\"tempdirectory\"      value=\"tmp\" /&gt;\n  &lt;item key=\"maxlogsizeinmo\"     value=\"5\" /&gt;\n  &lt;item key=\"nbdaystodeletelogs\" value=\"10\" /&gt;\n  &lt;item key=\"executionthreshold\" value=\"30\" /&gt;\n  &lt;!--Log level : NONE, INFO, TRACE, ERROR --&gt;\n  &lt;item key=\"loglevel\"           value=\"INFO\" /&gt;\n  &lt;item key=\"trustedservers\"     value=\"127.0.0.1\" /&gt;\n  &lt;item key=\"sshhost\"            value=\"127.0.0.1\" /&gt;\n  &lt;item key=\"sshkeydirectory\"    value=\"sshkeys\" /&gt;\n&lt;/config&gt;\n</code></pre> Key Description networkAddress IP address used to open the agent's TCP listening port. A.B.C.D format (0.0.0.0 for all interfaces of the machine) port Port used as the agent's TCP listening port. Numerical format. checktimeout Maximum time allowed for a check command. Once this period has passed, the check order is considered completed. (In seconds) logdirectory Agent's trace file recording directory. tempdirectory Agent's working directory maxlogsizeinmo Maximum size before rotation of the trace file (In Megabytes) nbdaystodeletelogs Retention period for trace files archived under logdirectory /logs-backup/ (In days) loglevel Log levels ('NONE', 'ERROR', 'INFO', 'TRACE') executionthreshold Maximum number of parallel executions for (Start/Stop/Custom actions). This parameter does not apply to check actions. trustedservers List of IP addresses, or Dns names of XComponent AppControl servers authorized to contact the agent (Can be empty) ignoretrustedservers Disable trusted server option sshhost This parameter allows the agent to perform an SSH session with the account specified in the configuration of the application. The file containing the private key to use is located in the 'sshkeydirectory' directory and bears the name of the targeted user. This property works exclusively on Linux agent. sshkeydirectory Directory for storing Ssh private key files. The name of the expected files must be named with the name of the user targeted by the application configuration. The public key must be present in the ~/ssh/authorized_keys file of the remote account"},{"location":"agents/#environment-variables-configuration","title":"Environment variables configuration","text":"<p>Config.dat configuration supports environment variables as a value.</p> <p>Under Microsoft Windows:</p> <p>In config.dat you can use environment variables with the following pattern: %VARIABLE%.</p> <pre><code>&lt;config&gt;\n...\n  &lt;item key=\"tempdirectory\" value=\"%TEMP%\" /&gt;\n...\n&lt;/config&gt;\n</code></pre> <p>Under Linux/Unix:</p> <p>In config.dat you can use environment variables with the following pattern: $VARIABLE.</p> <pre><code>&lt;config&gt;\n...\n   &lt;item key=\"tempdirectory\" value=\u201d$TEMP\" /&gt;\n...\n&lt;/config&gt;\n</code></pre> <p>Note:</p> <pre><code>Each item key of the config.dat file can be overriden  by an environment variable named XC_MYITEMKEYINUPPERCASE. The priority is the following:\n1. If an XC_... variable exists the agent will use it\n2. The values in the config.dat are used only if the XC_... variables don't exist.\n\nExample:\nif an env variable named XC_TEMPDIRECTORY exists, this value will be used instead of the variable 'tempdirectory' defined in the config.dat.\n\n</code></pre>"},{"location":"agents/#checking-that-agents-port-is-opened","title":"Checking that agent's port is opened","text":"<p> In some situations, we need to check that the agent's port is correctly bind and accessible from another computer.</p> <ol> <li>Checking that the agent binds on its port (locally):</li> </ol> <pre><code>curl localhost:12567\n</code></pre> <p>If the agent is running, the expected message is:</p> <pre><code>curl: (52) Empty reply from server\n</code></pre> <p>If the agent is not running, the message is:</p> <pre><code>curl: (7) Failed to connect to localhost port 12567 after 2267 ms: Couldn't connect to server\n</code></pre> <ol> <li>Checking that the agent binds on its port (from a remote machine):</li> </ol> <pre><code>curl mymachine:12567\n</code></pre> <p>If the agent is running, the expected message is:</p> <pre><code>curl: (52) Empty reply from server\n</code></pre> <p>If the agent is not running or unreachable (for example behind a firewall), the message is:</p> <pre><code>curl: (7) Failed to connect to mymachine port 12567 after 2267 ms: Couldn't connect to server\n</code></pre> <p>Note:</p> <pre><code>You can use the AppControl Gateway to both check agent connectivity and also to execute commands on the agent host.\n</code></pre> <p>Please refer to the following link</p>"},{"location":"agentsdeployment/","title":"Automatic Deployment of Agents","text":""},{"location":"agentsdeployment/#deploy-agents-automatically-via-the-gateway","title":"Deploy Agents Automatically via the Gateway","text":"<p>AppControl simplifies the process of deploying agents in your infrastructure by leveraging the gateway. To automate the deployment of agents, AppControl requires SSH access to the target infrastructure using the private SSH key. Below are the steps to configure SSH, generate SSH keys on both Linux and Windows, and provide the necessary key to enable automatic deployment.</p>"},{"location":"agentsdeployment/#1-configure-ssh-access","title":"1. Configure SSH Access","text":"<p>For AppControl to deploy agents automatically, the gateway needs access to the target machines via SSH. Ensure that SSH is properly configured on your target systems.</p> <ul> <li>Port: By default, SSH uses port 22, but AppControl allows you to customize this if needed.</li> <li>User Permissions: The user account that AppControl will use for SSH must have sufficient permissions to install and manage agents on the target machine.</li> </ul> <p>Note: The public SSH key must be added to the <code>~/.ssh/authorized_keys</code> file on the SSH server of the target machines. This ensures that AppControl can authenticate using the corresponding private SSH key.</p>"},{"location":"agentsdeployment/#2-generate-ssh-keys-private-key-required-by-appcontrol","title":"2. Generate SSH Keys (Private Key Required by AppControl)","text":"<p>To allow AppControl to manage agent deployment via the gateway, the private SSH key must be provided. Follow the steps below to generate SSH keys on Linux or Windows.</p>"},{"location":"agentsdeployment/#linux-or-macos","title":"Linux (or macOS)","text":"<p>To generate SSH keys on Linux or macOS:</p> <ol> <li>Open a terminal.</li> <li> <p>Run the following command to generate a new SSH key pair:</p> <p><code>ssh-keygen -t rsa -b 2048 -f ~/.ssh/appcontrol_key</code></p> <ul> <li><code>-t rsa</code>: Specifies the RSA algorithm.</li> <li><code>-b 2048</code>: Specifies the key length (2048 bits).</li> <li><code>-f ~/.ssh/appcontrol_key</code>: Saves the key pair to the specified file (<code>appcontrol_key</code>).</li> </ul> </li> <li> <p>When prompted for a passphrase, press Enter to leave it empty (or add a passphrase if extra security is required).</p> </li> </ol> <p>This command will generate two files:</p> <ul> <li>Private key: <code>~/.ssh/appcontrol_key</code></li> <li> <p>Public key: <code>~/.ssh/appcontrol_key.pub</code></p> </li> <li> <p>Add the public key to the <code>authorized_keys</code> file on the target machine:</p> <p><code>cat ~/.ssh/appcontrol_key.pub &gt;&gt; ~/.ssh/authorized_keys</code></p> </li> </ul>"},{"location":"agentsdeployment/#windows","title":"Windows","text":"<p>To generate SSH keys on Windows, you can use either Git Bash or PowerShell (with OpenSSH).</p>"},{"location":"agentsdeployment/#option-1-using-git-bash","title":"Option 1: Using Git Bash","text":"<ol> <li>Install Git for Windows if not already installed.</li> <li>Open Git Bash.</li> <li> <p>Run the following command to generate an SSH key pair:</p> <p><code>ssh-keygen -t rsa -b 2048 -f ~/.ssh/appcontrol_key</code></p> </li> <li> <p>When prompted, press Enter to use the default file location, and leave the passphrase empty (or add one if preferred).</p> </li> <li> <p>Add the public key to the <code>authorized_keys</code> file on the target machine:</p> <p><code>cat ~/.ssh/appcontrol_key.pub &gt;&gt; ~/.ssh/authorized_keys</code></p> </li> </ol>"},{"location":"agentsdeployment/#option-2-using-powershell-windows-1011","title":"Option 2: Using PowerShell (Windows 10/11)","text":"<ol> <li>Open PowerShell as an administrator.</li> <li> <p>Run the following command to generate an SSH key pair:</p> <p><code>ssh-keygen -t rsa -b 2048 -f $env:USERPROFILE\\.ssh\\appcontrol_key</code></p> </li> </ol> <p>This will generate two files:</p> <ul> <li>Private key: <code>C:\\Users\\YourUsername\\.ssh\\appcontrol_key</code></li> <li> <p>Public key: <code>C:\\Users\\YourUsername\\.ssh\\appcontrol_key.pub</code></p> </li> <li> <p>Add the public key to the <code>authorized_keys</code> file on the target machine:</p> <p><code>Get-Content $env:USERPROFILE\\.ssh\\appcontrol_key.pub | Out-File -Append -Encoding ascii $env:USERPROFILE\\.ssh\\authorized_keys</code></p> </li> </ul>"},{"location":"agentsdeployment/#3-ssh-server-on-windows-optional","title":"3. SSH Server on Windows (Optional)","text":"<p>For Windows systems, you can optionally deploy an SSH server to allow AppControl to connect and manage agents. OpenSSH Server is an optional feature in Windows, which you can enable via the following steps:</p> <ol> <li>Go to Settings &gt; Apps &gt; Optional Features.</li> <li>Scroll down and click Add a feature.</li> <li>Search for OpenSSH Server, select it, and click Install.</li> </ol> <p>For more detailed instructions, refer to the official Windows documentation.</p> <p>Once installed, configure the SSH server, and ensure the public key is added to the <code>authorized_keys</code> file.</p>"},{"location":"agentsdeployment/#4-deploy-agents-via-the-gateway","title":"4. Deploy Agents via the Gateway","text":"<p>Once SSH is configured and the private key is provided, follow these steps to deploy agents using the AppControl gateway:</p> <ol> <li> <p>Select the Target Machines:</p> <ul> <li>In the AppControl dashboard, go to the \"Deploy Agents\" section and select the machines where agents should be deployed.</li> </ul> </li> <li> <p>Verify Connectivity:</p> <ul> <li>AppControl will verify the SSH connection to the target machines using the private SSH key.</li> </ul> </li> <li> <p>Deploy Agents:</p> <ul> <li>Once the connection is established, AppControl will automatically deploy the agents to the selected machines.</li> </ul> </li> </ol> <p>Installation Paths:</p> <ul> <li>On Windows: Agents will be installed in <code>C:/ProgramData/appcontrol/agent</code>.</li> <li>On Linux: The installation folder is <code>/opt/appcontrol/xcagent</code>.</li> <li>On macOS: The installation folder is <code>~/appcontrol/xcagent</code>.</li> </ul>"},{"location":"agentsdeployment/#5-troubleshooting-ssh-connection","title":"5. Troubleshooting SSH Connection","text":"<p>If you encounter issues with the SSH connection during the deployment process, check the following:</p> <ol> <li> <p>Private SSH Key:</p> <ul> <li>Ensure that the private SSH key is properly configured and uploaded to AppControl.</li> </ul> </li> <li> <p>SSH Port and User Permissions:</p> <ul> <li>Verify that the SSH port and user permissions are correctly set up on the target machine.</li> </ul> </li> <li> <p>Firewall and Network Configuration:</p> <ul> <li>Check firewall rules or network configurations that might block SSH access to the target machine.</li> </ul> </li> </ol>"},{"location":"agentsdeployment/#6-provide-the-private-ssh-key-to-appcontrol","title":"6. Provide the Private SSH Key to AppControl","text":"<p>AppControl requires the private SSH key for authentication during agent deployment. The public key is added to the target machines in the <code>~/.ssh/authorized_keys</code> file, and the private key remains with AppControl to establish the connection.</p> <ol> <li>Locate the Private Key:<ul> <li>Linux: <code>~/.ssh/appcontrol_key</code></li> <li>Windows: <code>C:\\Users\\YourUsername\\.ssh\\appcontrol_key</code></li> </ul> </li> <li>Upload the Private Key to AppControl:<ol> <li>Log in to the AppControl dashboard.</li> <li>Navigate to Gateway Configuration and select the gateway that will manage the agent deployment.</li> <li>Upload the private SSH key (<code>appcontrol_key</code>).</li> <li>AppControl will securely store the key and use it for deploying agents.</li> </ol> </li> </ol> <p>Note: The private SSH key remains confidential and is only used by AppControl to establish a secure SSH connection to the target machines. The corresponding public key should already be added to the <code>~/.ssh/authorized_keys</code> file on the target machines.</p> <p>To open the deployment form, first select the gateway, then navigate to the \"Deploy Agent\" tab.</p> <p></p>"},{"location":"bestpractices/","title":"Agents/Gateways configuration best practices","text":"<p>According to your configuration, differents badges will be displayed in the UI. The badges are indicators which are used to secure your I.S (Information System).</p> <p>The badges are displayed in the Agents view.</p> <p></p>"},{"location":"bestpractices/#protocol-badges","title":"Protocol badges","text":"<ul> <li>The first badge encourages the use of a recent version of the Tls protocol:</li> </ul> Protocol Badge Tls13 Tls12 Tls - Ssl"},{"location":"bestpractices/#gateway-badges","title":"Gateway badges","text":"<ul> <li>The second badge encourages the use of a gateway to access agents. Indeed, the gateways are there to guarantee a stronger isolation at the network level and at the application level.</li> </ul> Number of gateways by agent Badge At least one None"},{"location":"bestpractices/#resilience-badges","title":"Resilience badges","text":"<ul> <li>The third badge encourages the use of several sites (at least primary and secondary). This declaration of the different sites is configured using the \"trustedservers\" variable in the agent's config.dat file. If \"ignoretrustedservers\" a \"gold medal\" will be displayed.</li> </ul> Number of servers declared in \"trustedserver\" Badge At least two One None"},{"location":"centreon/","title":"Centreon Import","text":"<p>The X4B platform includes a mechanism for importing your current Centreon (or Nagios) setup. This allows you to start off with a draft AppControl map file which includes all the hosts and services that you have defined in your Centreon configuration.</p>"},{"location":"centreon/#appcontrol-map","title":"AppControl map","text":"<p>The import will create one AppControl component for each host, and one for each service, with the host component being designated as a parent of the service component. The parent-child relationship denotes a dependency relation, where the child depends on a properly working parent to perform its own function.</p> <p>You can designate one of your servers as a bastion host. If you do, it is assumed that you will deploy an AppControl agent on it, and then that server will be used to run remote checks on other hosts, using the ping or ssh commands, for example.</p> <p>By default, the host components have a check command that does ping -c 1 &lt;hostname&gt;. The service components are created with sample check, start, and stop commands that simulate the actual checks using a temporary file. All these default commands assume the agent is running on a linux machine, but you can also configure your map to deploy the agents on Windows servers (see xxx for more details on AppControl agents).</p>"},{"location":"centreon/#importing-your-setup","title":"Importing your setup","text":"<p>The import tool is a Windows binary that you can download from here. To import your setup, first log on to your Centreon server, and export your configuration to a text file, with the following command:</p> <pre><code>centreon -u &lt;admin_user&gt; -p &lt;admin_password&gt; -e &gt; centreon_export.txt\n</code></pre> <p>Second, run the import tool, specifying your export file as the input file:</p> <pre><code>ac_from_centreon.exe -f centreon_export.txt -n CentreonExported -v 1.0\n</code></pre> <p>This creates a file called CentreonExported,1.0.xml in the current directory (you are free to pick any name and version you want, see the available options below). You can open this file in the editor of your choice to inspect or edit it, and you can upload it to AppControl with the New button on the AppControl UI. Other options are available:</p> <pre><code>Usage: ac_from_centreon.exe OPTIONS\nOptions:\n    -f &lt;filepath&gt;\n    -r | --root-host &lt;hostname&gt;\n    -b | --bastion-host &lt;hostname&gt;\n    -n &lt;map name&gt; (required)\n    -v &lt;version&gt; (required)\n    -o &lt;map_filepath&gt;\n</code></pre> <p>The --root-host option lets you specify one server as being the root, in the AppControl architecture map, of the servers graph. This indicates that all the other server depend on this one; you would typically choose a server playing some essential role, such as a DNS server.</p> <p>The --bastion-host option lets specify one server as being the bastion, as described above.</p> <p>The -n and -v options are required, as they define the map name and version. If no path is given for the map file, the file gets created in the current directory with the name &lt;map_name&gt;,&lt;version&gt;.xml; alternatively, you may specify a different path and name using the -o option. </p>"},{"location":"cli/","title":"AppControl Cli","text":""},{"location":"cli/#latest-available-versions","title":"Latest Available versions","text":"Operating System Format Latest version Microsoft Windows / Linux zip AppControl Cli Zip N/A docker docker pull xcomponent/appcontrol-cli:latest"},{"location":"cli/#objectives","title":"Objectives","text":"<p>AppControl Cli is intended to start/stop/load/suspend Appcontrol's applications from the command line. This tool is mainly used to integrate AppControl in a scheduler/workload automation software. </p>"},{"location":"cli/#installation","title":"Installation","text":"<p>...</p>"},{"location":"cli/#configuration","title":"Configuration","text":"<p>...</p>"},{"location":"cmdb/","title":"AppControl CMDB Integration","text":"<p>AppControl can be integrated with a Configuration Management Database (cmdb).</p> <p>AppControl currently supports ServiceNow as a cmdb provider, but other providers such as iTop or EasyVista can also be considered. </p>"},{"location":"cmdb/#use-cases","title":"Use Cases","text":"<p>There can be several use cases for integrating AppControl and a cmdb:</p> <ul> <li>conformity check between operational reality and cmdb referential</li> <li>map (eg: AppControl Application) provisioning based on cmdb data </li> </ul>"},{"location":"cmdb/#conformity-check","title":"Conformity check","text":"<p>In the first use case, whenever a map is loaded, AppControl checks whether the objects declared in the map are present in the cmdb, and produces a report listing the elements that were found missing.</p> <p>Currently, nothing is ever added to the cmdb; a future version may offer the possibility for the user to choose whether to populate the cmdb with elements from the map.</p>"},{"location":"cmdb/#map-provisioning","title":"Map provisioning","text":"<p>In the second use case, the cmdb acts as the configuration repository for AppControl artefacts, such as the Component. For example, the cmdb may hold a standard set of actions that are expected to be present in certain components: when the actions are found to be missing in the map, they can be copied from the cmdb, ensuring that the Components in the operational reality match the cmdb view of the world.</p> <p>Eventually, it might be possible to generate entire maps from the cmdb, thereby ensuring automatic conformity. </p>"},{"location":"cmdb/#cmdb-integration-howto","title":"Cmdb Integration HOWTO","text":""},{"location":"cmdb/#cmdb-access-and-credentials","title":"Cmdb access and credentials","text":"<p>The first step is to define one or more cmdb objects in AppControl. In the Referential section at the bottom of the left-hand side panel, press the CMDB button to display the page where you can manage access to various CMDBs:</p> <p></p> <p>To register a new ServiceNow CMDB, press the register button and fill in the fields:</p> <ul> <li><code>Name</code> is the local AppControl identifier for this cmdb</li> <li><code>User</code>/<code>Password</code> are your credentials on the ServiceNow server</li> <li><code>ServiceNow Url</code> identifies the ServiceNow server you wish to use</li> </ul> <p>Once a cmdb has been defined, you can reference it in the map import wizard, to request a validation of the map being imported.</p>"},{"location":"cmdb/#map-import-wizard","title":"Map Import Wizard","text":"<p>When importing a new map file, the fifth step is the CMDB validation, where you are presented with the list of available cmdbs. </p> <p></p> <p>Make sure the cmdb server you want to use is up and running at this point. Click on its name and press Next. A progress bar indicates that validation is taking place (this can take a few moments). If every element in the map is matched to a corresponding element in the cmdb, a message will indicate that the validation has succeeded:</p> <p></p> <p>If the verification process detected configuration information in the cmdb that was not in the map (such as Component actions) this will also be indicated:</p> <p></p> <p>If any discrepancies were found when comparing the map to the cmdb, a report is shown listing the elements that were found to be missing:</p> <p></p>"},{"location":"cmdb/#understanding-the-servicenow-integration","title":"Understanding the ServiceNow integration","text":"<p>The following sections detail the mapping choices that were made to represent AppControl data in ServiceNow. Keep in mind that ServiceNow is very much configurable, and even lets you define custom data tables, so any integration might require specific work. </p>"},{"location":"cmdb/#mapping-between-appcontrol-and-servicenow","title":"Mapping between AppControl and ServiceNow","text":"<p>The following table shows the correspondance between AppControl concepts or objects, and ServiceNow resources.</p> AppControl ServiceNow Object ServiceNow Table Application Application cmdb_ci_appl Host Computer cmdb_ci_computer Component Service cmdb_ci_service Component hostref Computer-Service Relation cmdb_ci_rel Action Commands cmdb_running_process"},{"location":"cmdb/#representing-components-actions-in-servicenow","title":"Representing Components actions in ServiceNow","text":"<p>Each Component in AppControl has a mandatory <code>hostref</code> attribute linking to the server where the component is hosted. This link is represented by a ServiceNow <code>Depends on::Used by</code> relation.</p> <p>The actions defined on a Component are stored in the RunningProcess table (cmdb_running_process), with a link to the corresponding host. Here's the detailed mapping on the fields of the RunningProcess table:</p> AppControl Element Field name action name :: component name command action value parameters application name computer hostref"},{"location":"cmdb/#example","title":"Example","text":"<p>AppControl XML map file:</p> <pre><code>&lt;app name=\"inv_test_missing_from_map\" version=\"1.0\"&gt;\n  &lt;component name=\"inv_pricing_001\" description=\"An Invivoo component\" group=\"A group\"\n           hostref=\"inv_host_001\" authref=\"LOCAL\"redirectoutput=\"false\" type=\"file\"&gt;\n    &lt;action value=\"sandbox.sh check inv_pricing_001\" name=\"check\" /&gt;\n    &lt;action value=\"sandbox.sh enable inv_pricing_001\" name=\"enable\" /&gt;\n    &lt;action value=\"sandbox.sh disable inv_pricing_001\" name=\"disable\" /&gt;\n  &lt;/component&gt;\n</code></pre> <p>ServiceNow cmdb_running_process table record (extracts):</p> <pre><code>{\n    \"command\": \"sandbox.sh check inv_pricing_001\",\n    \"computer\": {\n        \"link\": \"https://dev78474.service-now.com/api/now/v1/table/cmdb_ci_computer/8ba1aa202f7320102cd8d49df699b687\",\n        \"value\": \"8ba1aa202f7320102cd8d49df699b687\"\n    },\n    \"name\": \"check::inv_pricing_001\",\n    \"parameters\": \"inv_test_missing_from_map\",\n}\n</code></pre>"},{"location":"cmdb/#populating-your-cmdb","title":"Populating your Cmdb","text":"<p>The cmdb can be populated by inserting individual objects using the cmdb provider's interface. But as the volume of data grows, populating your cmd can become a daunting task. Invivoo is developing tools to automate the creation of cmdb objects from AppControl maps [TO BE CONTINUED].</p>"},{"location":"contact/","title":"Contact Us","text":""},{"location":"contact/#contact-us","title":"Contact Us","text":"<p>If you have any questions, need support, or want to reach out for any reason, we\u2019re here to help!</p> Links Contact Us Fill out our contact form Support support@appcontrol.com Community <p> </p> Join our Slack channel"},{"location":"coreconcepts/","title":"Core Concepts of AppControl","text":"<p>AppControl is built on a set of core concepts that enable effective monitoring, control, and automation of your applications across both local and cloud-based environments. Understanding these concepts will help you make full use of the platform.</p>"},{"location":"coreconcepts/#1-agents","title":"1. Agents","text":"<p>AppControl uses agents to interact with your local infrastructure. These agents act as the bridge between your on-premises applications and the AppControl SaaS platform. Agents can be installed on both Windows and Linux systems, allowing for flexible integration with diverse IT environments.</p>"},{"location":"coreconcepts/#2-gateway","title":"2. Gateway","text":"<p>The gateway is the critical link between agents deployed on your local infrastructure and the AppControl SaaS platform. It facilitates secure and reliable communication, ensuring that actions taken on your applications are synchronized with the cloud.</p>"},{"location":"coreconcepts/#3-applications","title":"3. Applications","text":"<p>In AppControl, an application represents a collection of components that need to be monitored and managed. Each application is defined through a YAML configuration file, which describes its components and the actions that can be performed on them.</p>"},{"location":"coreconcepts/#4-components","title":"4. Components","text":"<p>A component is a critical part of an application and defines the actions that AppControl can perform. Each component is described by three primary actions: start, stop, and check. In addition, some components may have optional custom commands.</p>"},{"location":"coreconcepts/#command-types","title":"Command Types:","text":"<ul> <li>Check Command: Retrieves the current state of the component.</li> <li>Start Command: Starts the component, initiating processes or services.</li> <li>Stop Command: Stops the component, halting processes or services.</li> <li>Custom Commands: Optional commands that can be defined based on specific application requirements.</li> </ul>"},{"location":"coreconcepts/#dependency-behavior","title":"Dependency Behavior:","text":"<ul> <li>Parent-Child Dependencies: Components follow a parent-child hierarchy. A component can only start if its parent components are already started. Similarly, a component can only stop if its child components are already stopped.</li> <li>Startup Sequence: When starting an application, AppControl first starts the parent components and then proceeds to start their child components.</li> <li>Shutdown Sequence: When stopping an application, AppControl stops child components first before stopping their parent components.</li> </ul>"},{"location":"coreconcepts/#5-diagnostics-actions-on-demand-actions","title":"5. Diagnostics Actions (On-Demand Actions)","text":"<p>AppControl provides on-demand actions, also referred to as diagnostics actions, which allow you to perform manual checks or gather diagnostic information at any time.</p> <ul> <li>Purpose: Diagnostics actions help troubleshoot issues, gather performance metrics, or run custom scripts on-demand without waiting for an incident to trigger automated actions.</li> <li>Customizable: You can define these actions in the YAML file and provide flexible input parameters that can be edited by users as needed.</li> <li>Example: A diagnostics action might involve checking log files, gathering system metrics, or testing connectivity between components.</li> </ul>"},{"location":"coreconcepts/#6-diagnostics-and-issue-resolution","title":"6. Diagnostics and Issue Resolution","text":"<p>AppControl includes built-in diagnostics to detect and resolve common issues related to component states, particularly focusing on dependency relationships between components.</p>"},{"location":"coreconcepts/#diagnostic-situation","title":"Diagnostic Situation:","text":"<ul> <li>Orphan Components: AppControl identifies issues when components are in an incorrect state relative to their parent or child components. For example:<ul> <li>Issue 1: A component is stopped while its parent is running.</li> <li>Issue 2: A component is running while its child components are stopped.     In these cases, AppControl flags the issue and provides diagnostic information.</li> </ul> </li> </ul>"},{"location":"coreconcepts/#resolution-process","title":"Resolution Process:","text":"<ul> <li>Stop Orphaned Components: When an orphaned component is detected (i.e., a component that is running without its necessary parent components), AppControl will stop the orphaned components to maintain consistency.     </li> <li>Healthy State: Once the issues are resolved, the system reaches a healthy state, ensuring all components are properly aligned with their parent-child dependencies.     </li> <li>Restart by Branch: AppControl can restart components by \"branch,\" ensuring that all parent and child components are properly started in sequence, maintaining the application's integrity.     </li> </ul>"},{"location":"coreconcepts/#7-automated-recovery-actions","title":"7. Automated Recovery Actions","text":"<p>In AppControl, automated recovery actions are designed with caution to prevent escalating issues. By default, AppControl does not automatically restart components to avoid the risk of increasing a problem. Instead, AppControl offers a flexible approach where users can define scheduled auto-restart actions using built-in cron expressions.</p>"},{"location":"coreconcepts/#8-application-monitoring-focus","title":"8. Application Monitoring Focus","text":"<p>AppControl is different from traditional monitoring solutions because it is application-centric. While other tools often focus on infrastructure (e.g., servers and networks), AppControl monitors and manages the actual applications, which are the heart of your business.</p>"},{"location":"coreconcepts/#summary","title":"Summary","text":"<p>Understanding these core concepts will enable you to effectively use AppControl to monitor, manage, and automate your applications. Whether you are working with legacy on-premises systems or cloud-native applications, AppControl\u2019s agents, gateway, and application-centric approach offer the flexibility and control you need to maintain uptime and operational efficiency.</p>"},{"location":"dynamicMapInformations/","title":"Dynamic informations","text":"<p>An application is a set of components defined statically using a YAML/XML format (see: Create an application). However, the application can be enriched with dynamic information. Dynamic information is returned by the <code>check</code> command.</p> <p>To return dynamic information, the <code>check</code> command should log some data to the standard output, which must follow this format:</p> <pre><code>&lt;appcontrol&gt; APPCONTROL JSON OBJECT &lt;/appcontrol&gt;\n</code></pre> <pre><code>{\n    \"link\": \"Hyperlink to wathever you want\", //Optional\n    \"name\": \"Name of the component\",          //Required\n    \"displayName\": \"Display name\",            //Optional\n    \"state\": \"  Initializing |\n                InError |\n                Start |\n                Starting |\n                Started |\n                Stop |\n                Stopping |\n                Stopped \",     //Optional\n    \"parents\":                 //Optional but highly recommanded\n    [\n        \"Parent1\",\n        \"Parent2\",\n    ],\n    \"exitCode\": 256, //Optional\n    \"color\": \"Color of the code RGB format or hexa code ('255,255,255' or #FFFFFF\", //Optional\n    \"Type\": \" Used to display an icon on the map. An url to an image (png, jpeg or svg) can be set. Anyway you can use one of the following value: browser, cd, chip, data-information, devises, dollar, euro, file, green-thermometer, hdd, memflash, memory, middleware, network, orange-thermometer, pounds, process, service, tools, user, yen\",  //Optional\n    \"groupName\": \"Name of the group\",  //Optional\n    \"customActions\": //Optional\n        [\n            {\n            \"visibility\": \"Private\",\n            \"customActionName\": \"echo Action\",\n            \"customActionDescription\":  null,\n            \"customActionCommandLine\": \"echo $(message)\",\n            \"parallelCustomAction\": false,\n            \"parameters\":\n            [\n                {\n                    \"parameterName\":\"message\",\n                    \"description\": \"\",\n                    \"defaultValue\": \"Welcome message\",\n                    \"validationRule\": \"*\",\n                    \"isEditable\": true\n                }\n            ]\n            }\n        ],\n    \"filters\": {\"filter name 1\": [\"filter values\"] ,\n                \"filter name 2\": [\"filter values\"]\n                }  //Optional,\n    \"dynamicTree\" : [\n            {\n                //A json object with the properties defined above\n            }\n    ] //Optional,\n}\n</code></pre> <p>A full example is available in this documentation:</p> <ul> <li>Application sample</li> <li>JSON dynamic data</li> </ul> <p>In this example, dynamic components are displayed with an octagonal shape, while static components are displayed with a square shape.</p> <p></p>"},{"location":"gettingStarted/","title":"Getting Started with AppControl","text":"<p>AppControl is designed as a simple, cloud-based Software as a Service (SaaS) solution, allowing you to monitor and manage your applications from anywhere, without the need for complex on-premises infrastructure. This quick-start guide will help you set up and begin using AppControl in minutes.</p> <p>For businesses with specific requirements\u2014whether it\u2019s tailored SLAs, on-premises deployment, or other custom needs\u2014please Contact us to discuss how we can meet your specific goals.</p>"},{"location":"gettingStarted/#try-demo","title":"Try AppControl with a Demo (No Local Setup Required)","text":"<p>To help you get started quickly, AppControl offers a demo environment that allows you to explore the core features of the platform without the need for any local setup or infrastructure. This is the perfect way to understand how AppControl can reduce downtime and streamline incident response.</p> <ul> <li>Log in:  - Go to the XComponent AppControl website  - Log in using a social provider  - You're done! You can now get started with AppControl!</li> <li>Import a demo application: </li> </ul> <p>Click on the Overview/New Application button, select XML/YAML file from url and paste the following link of an \"Hello World\" application.</p>      Copy Application Link    <p></p> <p> </p> <p>Follow the wizard (clicking on 'Next' button). In the 'Agent/Gateway configuration' section select 'SaaS Gateway'. Then scroll down on the bottom of the page and click on \"Create my application\".</p> <p></p> <ul> <li>Explore the UI: Explore monitoring, incident management, and actions.</li> </ul> <p> </p> <p>The demo version provides a hands-on look at AppControl\u2019s capabilities.</p>"},{"location":"gettingStarted/#some-explanations-about-the-demo-yaml-file","title":"Some explanations about the Demo YAML file","text":""},{"location":"gettingStarted/#yaml-configuration-for-helloworld-application","title":"YAML Configuration for \"helloworld\" Application","text":"<p>The YAML configuration file for the \"helloworld\" application defines how the application is monitored, controlled, and secured through AppControl. This guide explains the structure and objectives of the YAML file, allowing you to customize your own configurations.</p>"},{"location":"gettingStarted/#objectives-of-the-yaml-configuration","title":"Objectives of the YAML Configuration","text":"<p>The primary purpose of the YAML configuration file is to outline the application\u2019s structure, define its components, and specify the actions AppControl will perform. It also describes how agents and authentication methods are used to securely communicate with and control the application.</p>"},{"location":"gettingStarted/#key-objectives","title":"Key Objectives","text":"<ol> <li> <p>Define the Application Name, Version, and Components</p> <ul> <li>The YAML file begins by specifying the application\u2019s <code>Name</code> and <code>Version</code>, followed by its components. In this case, the component \"hello\" represents the main part of the \"helloworld\" application.</li> </ul> </li> <li> <p>Establish Agent-Based Monitoring and Control</p> <ul> <li>An agent, called <code>LOCAL</code>, is defined to manage the application. This agent communicates over port <code>12567</code> using the TLS 1.2 protocol for secure connections. The agent monitors the application\u2019s state and can execute actions such as starting or stopping the application.</li> </ul> </li> <li> <p>Define Secure Authentication Mechanism</p> <ul> <li>The file includes an authentication method, <code>LOCAL</code>, to secure the communication between the agent and the application components. This ensures that only authorized agents can execute actions on the application.</li> </ul> </li> <li> <p>Configure Component Actions</p> <ul> <li>The YAML file defines a series of actions that AppControl can perform on the \"hello\" component:<ul> <li>Check Action: Checks the existence and content of the <code>hello.txt</code> file.</li> <li>Start Action: Starts the application by creating the <code>hello.txt</code> file.</li> <li>Stop Action: Stops the application by removing the <code>hello.txt</code> file.</li> <li>Custom Action: Allows users to input a custom message and execute the \"Say Hello\" command.</li> </ul> </li> </ul> </li> <li> <p>Group Components for Easier Management</p> <ul> <li>The <code>Group</code> field organizes components into logical groups for easier management. In this case, the \"hello\" component is grouped under \"Hello group\".</li> </ul> </li> <li> <p>Provide a Template for Automation and Customization</p> <ul> <li>The YAML file serves as a template for automating routine tasks, such as starting and stopping the application, while also allowing customization through user-defined actions.</li> </ul> </li> <li> <p>Ensure Scalability and Extensibility</p> <ul> <li>The structure of the YAML file allows you to scale and extend the configuration by adding more agents, components, or actions as needed for more complex applications.</li> </ul> </li> </ol>"},{"location":"gettingStarted/#example-yaml-configuration","title":"Example YAML Configuration","text":"<p>Here\u2019s an example of the YAML configuration for the \"helloworld\" application:</p> <pre><code>Name: helloworld\nVersion: v1\nIcon: {}\nAgents:\n    - Name: LOCAL\n      Port: 12567\n      SslProtocol: tls12\nAuthentications:\n    - Name: LOCAL\nComponents:\n    - Name: hello\n      Agent:\n          AgentName: LOCAL\n          AuthentificationName: LOCAL\n      Icon:\n          SystemName: file\n      Group: Hello group\n      Description: Hello World\n      Actions:\n          - Name: check hello\n            Type: check\n            Value: cat hello.txt\n          - Name: start hello\n            Type: start\n            Value: echo hello &gt; hello.txt\n          - Name: stop hello\n            Type: stop\n            Value: rm hello.txt\n          - Name: Say Hello\n            Type: custom\n            Value: echo $(message)\n            InputParameters:\n                - Name: message\n                  Value: Hello\n                  CanEdit: true\n                  Validation: '*'\n</code></pre>"},{"location":"gettingStarted/#connecting-to-local-infrastructure","title":"Connecting to Local Infrastructure","text":"<p>If you wish to manage applications running in your on-premises environment, AppControl can be connected to your local infrastructure through agents and gateways. While this is an advanced setup, it allows for seamless integration with both legacy and cloud applications.</p> <p>For detailed instructions on how to connect to your local infrastructure, including agent installation and gateway setup, please refer to the documentation.</p>"},{"location":"itil/","title":"\ud83d\udccc AppControl and ITIL: A Cross-Team Tool for Incident Management and Continuous Improvement","text":""},{"location":"itil/#the-gap-in-traditional-itil-approaches","title":"\ud83c\udfaf The Gap in Traditional ITIL Approaches","text":"<p>In a standard ITIL approach, ITSM tools (ServiceNow, Jira Service Management, BMC Helix...) are primarily focused on ticket management. They structure incident, problem, and change tracking but have several limitations:</p> <ul> <li>Fragmented teams: Operations, Development, Support, and Business often work in silos using different tools.</li> <li>Lack of application visibility: Incidents are often reported without a clear link to the affected components.</li> <li>Reactive rather than proactive management: Incident analysis relies on often incomplete or manual data.</li> </ul> <p>These limitations lead to wasted time, diagnostic errors, and inefficiencies in incident and problem management.</p>"},{"location":"itil/#appcontrol-a-cross-team-solution-for-itil","title":"\ud83d\ude80 AppControl: A Cross-Team Solution for ITIL","text":"<p>AppControl acts as the missing link between ITSM and application management. Its added value is based on four key pillars:</p>"},{"location":"itil/#1-automatically-linking-incidents-to-it-components","title":"1\ufe0f\u20e3 Automatically Linking Incidents to IT Components","text":"<p>\u2705 Each incident is directly associated with the impacted application components (services, databases, APIs, VMs...). \u2705 Reduced diagnostic time and better understanding of dependencies.</p>"},{"location":"itil/#2-facilitating-cross-team-collaboration","title":"2\ufe0f\u20e3 Facilitating Cross-Team Collaboration","text":"<p>\u2705 A shared view of applications between operations, development, support, and business teams. \u2705 Eliminates silos: every team can see the impact of incidents on critical components.</p>"},{"location":"itil/#3-accelerating-resolution-and-continuous-improvement","title":"3\ufe0f\u20e3 Accelerating Resolution and Continuous Improvement","text":"<p>\u2705 Automation of information gathering and diagnostics. \u2705 Incident history tracking and root cause identification to reduce recurring problems.</p>"},{"location":"itil/#4-an-ideal-itsm-complement-evolved-cmdb","title":"4\ufe0f\u20e3 An Ideal ITSM Complement (Evolved CMDB)","text":"<p>\u2705 AppControl enhances ITIL management by providing a dynamic SI mapping. \u2705 A direct link between incidents, problems, and technical components, facilitating post-mortem analysis and continuous improvement.</p>"},{"location":"itil/#why-choose-appcontrol-in-an-itil-approach","title":"\ud83d\udd25 Why Choose AppControl in an ITIL Approach?","text":"ITIL Criteria Without AppControl With AppControl \ud83d\udd0d Application Visibility Incidents often disconnected from real components Incidents directly linked to IT components \ud83c\udfd7\ufe0f Cross-Team Collaboration Silos between Ops, Dev, Support, and Business A unified and shared incident view \u23f3 MTTR (Mean Time to Repair) Reduction Manual and slow analysis Rapid diagnosis via dynamic mapping \ud83d\udd04 Continuous Improvement Difficult to identify root causes Incident pattern analysis and proactive prevention"},{"location":"itil/#use-case-incident-management-with-appcontrol","title":"\ud83d\udca1 Use Case: Incident Management with AppControl","text":"<p>\ud83d\udd34 Without AppControl:</p> <ol> <li>An incident is detected on a critical application.</li> <li>The support team opens an ITSM ticket.</li> <li>Manual research is conducted to identify affected components.</li> <li>Difficulty in determining the cause and impact.</li> <li>Long resolution time and risk of recurrence.</li> </ol> <p>\ud83d\udfe2 With AppControl:</p> <ol> <li>AppControl detects the incident and immediately identifies the impacted components.</li> <li>Teams receive an enriched notification with key information.</li> <li>Resolution is accelerated thanks to mapping and associated logs.</li> <li>A post-mortem analysis helps prevent similar incidents.</li> </ol>"},{"location":"itil/#appcontrol-modernizing-itil-with-an-agile-approach","title":"\ud83c\udfaf AppControl: Modernizing ITIL with an Agile Approach","text":"<p>AppControl does not replace ITSM tools but complements them intelligently, facilitating cross-team information sharing and optimizing incident and problem resolution.</p> <p>\u2705 Unified application and infrastructure visibility. \u2705 Enhanced cross-team collaboration. \u2705 Continuous improvement and recurrence reduction.</p>"},{"location":"mainfeatures/","title":"Main Features of AppControl","text":"<p>AppControl offers a variety of features that help you monitor and manage critical business applications efficiently. Below is a list of the key features available in AppControl.</p>"},{"location":"mainfeatures/#1-application-dashboard","title":"1. Application Dashboard","text":"<p>Monitor the status of your applications in real time.</p> <ul> <li>Main Statuses:<ul> <li>Started: Application is running as expected.</li> <li>Stopped: Application is not currently running.</li> <li>Degraded: Application is running but has performance or availability issues.</li> <li>Error: Application has encountered an error and needs attention.</li> </ul> </li> </ul> <p></p>"},{"location":"mainfeatures/#2-application-operations-history","title":"2. Application Operations History","text":"<p>Track all changes and events related to your applications over time.</p> <ul> <li>Logs: Detailed logs of when applications were started, stopped, or when any issues occurred.</li> <li>Audit trail: A comprehensive view of all actions taken within the system.</li> </ul> <p></p>"},{"location":"mainfeatures/#3-action-buttons-startstop","title":"3. Action Buttons: Start/Stop","text":"<p>Easily control the lifecycle of your applications.</p> <ul> <li>Start: Quickly start any application.</li> <li>Stop: Gracefully shut down applications.</li> </ul> <p></p> <ol> <li>Activate/Deactivate applications</li> <li>Start aplication</li> <li>Stop application</li> <li>Cancel current operation (Start/Stop)</li> <li>Force check actions</li> <li>Edit current application</li> <li>Display filters</li> <li>Advanced settings</li> <li>Show/Hide groups (groups are used to group components)</li> </ol>"},{"location":"mainfeatures/#4-custom-actions-on-demand-actions","title":"4. Custom Actions (On-Demand Actions)","text":"<p>Define and execute custom actions tailored to your application\u2019s needs.</p> <ul> <li>Examples:<ul> <li>Diagnostics checks</li> <li>Cleanup tasks</li> <li>Restart specific components</li> </ul> </li> </ul> <p></p>"},{"location":"mainfeatures/#5-application-sharing-feature","title":"5. Application Sharing Feature","text":"<p>AppControl offers a convenient feature for sharing applications with specific users. This can be done in two ways: either by generating a sharing code, which can be distributed among users to access the application, or by sharing the application directly with a specific user by entering their username. This feature simplifies collaboration and access management, ensuring the right users can easily interact with the applications they need.</p> <p> </p>"},{"location":"mainfeatures/#6-notifications","title":"6. Notifications","text":"<p>Stay informed of application statuses and incidents with integrated notification systems.</p> <ul> <li>Notification channels:<ul> <li>SMS alerts for critical events.</li> <li>Microsoft Teams notifications to keep your team updated in real time.</li> </ul> </li> </ul> <p></p>"},{"location":"mainfeatures/#7-status-page","title":"7. Status Page","text":"<p>The Status Page in AppControl provides a detailed overview of the availability and health of your critical applications. This page displays the percentage of availability for each application, allowing you to monitor uptime and quickly identify potential issues over the past few days.</p>"},{"location":"mainfeatures/#key-features","title":"Key Features:","text":"<ul> <li>Application Availability: Shows the percentage of time each application was available and running smoothly, helping you assess the stability and reliability of your applications.</li> <li>Historical Data: Analyze the performance of applications over a specific period (e.g., the last 7 or 30 days) to gain insights into trends or recurring issues.</li> <li>Color-Coded Indicators:<ul> <li>Green: High availability (e.g., &gt; 75%)</li> <li>Yellow: Moderate availability (e.g., 50-75%)</li> <li>Red: Low availability or critical issues (e.g., &lt; 50%)</li> </ul> </li> <li>Interactive Graphs: Visual representations of uptime fluctuations, making it easy to visualize downtime and availability trends.</li> </ul> <p>This page helps ensure that your applications maintain high levels of availability and reliability by providing a clear and actionable view of their performance over time.</p> <p></p>"},{"location":"mainfeatures/#8-integration-with-legacy-and-cloud-applications","title":"8. Integration with Legacy and Cloud Applications","text":"<p>Seamlessly monitor both legacy on-premise applications and cloud-native services without requiring any modifications to existing applications.</p>"},{"location":"mainfeatures/#9-automated-recovery","title":"9. Automated Recovery","text":"<p>While automated recovery avoids restarting components by default, you can schedule auto restarts using built-in cron expressions to meet your operational needs.</p>"},{"location":"map/","title":"AppControl Application","text":"<p>In AppControl, applications (also referred to as \"maps\") were traditionally defined using an XML file. However, the preferred and modern format is now YAML, which offers greater flexibility and readability, making it easier to manage complex configurations.</p> <p>Applications in AppControl are structured as a hierarchy of components, with each component representing a critical part of the system. These components can be defined manually by editing YAML files, giving you full control over every aspect of the application setup. For users who prefer a more guided approach, AppControl also provides built-in wizards within the UI. These wizards simplify the process by generating application definitions based on your local infrastructure or from Azure environments, allowing you to create these files quickly and efficiently.</p> <p>Whether you choose to manually create your application configurations or leverage the built-in wizards, AppControl offers the flexibility to adapt to your preferred workflow, ensuring seamless integration with your existing systems.</p>"},{"location":"map/#yaml-format","title":"YAML Format","text":"<p>This document describes the configuration schema for AppControl applications, which is defined in YAML format. The YAML configuration file specifies the structure of an application, including its components, agents, authentication methods, scheduling, and actions.</p> <p>If you're unfamiliar with YAML, you can learn more about it here: YAML Documentation.</p> <p>In the YAML format, AppControl configurations are more readable and user-friendly. YAML offers greater support for advanced features and is the recommended format for defining applications in AppControl.</p> <p>The YAML file typically includes the following key information:</p> <ul> <li>Component Definitions: Each component is described by a set of commands:<ul> <li>Check Command: Mandatory for verifying the component's status.</li> <li>Start Command: Optional, used to start the component.</li> <li>Stop Command: Optional, used to stop the component.</li> <li>Custom Commands: Optional, for executing specific tasks or actions tailored to the component.</li> </ul> </li> <li>Agent List: Specifies the agents responsible for executing the commands for each component.</li> <li>Identity Information: Defines which users are authorized to run the commands for specific components.</li> <li>Scheduling Information: Allows scheduling of start/stop commands for automatic execution at predefined times.</li> </ul> <p>Full YAML Format described below:</p>"},{"location":"map/#1-name","title":"1. Name","text":"<ul> <li>Type: <code>string</code></li> <li>Description: The name of the service.</li> </ul>"},{"location":"map/#2-version","title":"2. Version","text":"<ul> <li>Type: <code>string</code></li> <li>Description: The version of the service.</li> </ul>"},{"location":"map/#3-description","title":"3. Description","text":"<ul> <li>Type: <code>string</code></li> <li>Description: A brief description of the service.</li> </ul>"},{"location":"map/#4-nbretry","title":"4. NbRetry","text":"<ul> <li>Type: <code>integer</code></li> <li>Description: The number of restart attempts for the service.</li> </ul>"},{"location":"map/#5-variables","title":"5. Variables","text":"<ul> <li>Type: <code>array</code></li> <li>Description: A list of variables used by the service.</li> <li>Properties:<ul> <li>Name: The name of the variable (<code>string</code>).</li> <li>Value: The value of the variable (<code>string</code>).</li> </ul> </li> </ul>"},{"location":"map/#6-agents","title":"6. Agents","text":"<ul> <li>Type: <code>array</code></li> <li>Description: A list of agents responsible for executing commands.</li> <li>Properties:<ul> <li>Name: The name of the agent (<code>string</code>).</li> <li>Address: The address of the agent (<code>string</code>).</li> <li>Port: The port used by the agent (<code>integer</code>).</li> <li>Gateway: The gateway used by the agent (<code>string</code>).</li> <li>DependsOnComponent: Specifies that the agent is triggered when the component is started (<code>string</code>).</li> <li>SslProtocol: The SSL protocol used by the agent (<code>tls</code>, <code>tls12</code>, or <code>tls13</code>).</li> </ul> </li> </ul>"},{"location":"map/#7-authentications","title":"7. Authentications","text":"<ul> <li>Type: <code>array</code></li> <li>Description: A list of authentication methods used for securing agent communications.</li> <li>Properties:<ul> <li>Name: The name of the authentication method (<code>string</code>).</li> </ul> </li> </ul>"},{"location":"map/#8-schedulingstart","title":"8. SchedulingStart","text":"<ul> <li>Type: <code>array</code></li> <li>Description: Scheduling of start tasks using cron expressions.</li> <li>Properties:<ul> <li>Name: The name of the start task (<code>string</code>).</li> <li>Expression: The cron expression that defines the schedule (<code>string</code>).</li> </ul> </li> </ul>"},{"location":"map/#9-schedulingstop","title":"9. SchedulingStop","text":"<ul> <li>Type: <code>array</code></li> <li>Description: Scheduling of stop tasks using cron expressions.</li> <li>Properties:<ul> <li>Name: The name of the stop task (<code>string</code>).</li> <li>Expression: The cron expression that defines the schedule (<code>string</code>).</li> </ul> </li> </ul>"},{"location":"map/#10-components","title":"10. Components","text":"<ul> <li>Type: <code>array</code></li> <li>Description: The components of the service, each defined by a set of properties and actions.</li> <li>Properties:<ul> <li>Name: The name of the component (<code>string</code>).</li> <li>DisplayName: The display name of the component (<code>string</code>).</li> <li>Agent: Defines the agent associated with the component, including:<ul> <li>AgentName: The name of the agent (<code>string</code>).</li> <li>AuthentificationName: The name of the authentication method used (<code>string</code>).</li> </ul> </li> <li>CheckFrequency: The frequency (in seconds) for checking the status of the component (<code>integer</code>).</li> <li>Icon: Icon properties, including:<ul> <li>SystemName: The system name of the icon (e.g., <code>browser</code>, <code>sqlserver</code>, etc.) (<code>string</code>).</li> <li>Url: The URL for the icon (<code>string</code>).</li> </ul> </li> <li>Group: The component's group (<code>string</code>).</li> <li>Description: A description of the component (<code>string</code>).</li> <li>Actions: A list of actions available for the component:<ul> <li>Name: The name of the action (<code>string</code>).</li> <li>Type: The type of the action (<code>string</code>).</li> <li>Value: The command to execute the action (<code>string</code>).</li> <li>RetryTime: The time to retry the action (<code>integer</code>).</li> <li>Visibility: Visibility of the action (<code>Private</code>, <code>Public</code>).</li> <li>WaitAfter: Time to wait after the action (<code>integer</code>).</li> <li>Description: A description of the action (<code>string</code>).</li> <li>InputParameters: Input parameters for the action:<ul> <li>Name: The name of the parameter (<code>string</code>).</li> <li>Value: The value of the parameter (<code>string</code>).</li> <li>Description: A description of the parameter (<code>string</code>).</li> <li>CanEdit: Specifies if the parameter can be edited (<code>boolean</code>).</li> <li>Validation: Validation rules for the parameter (<code>string</code>).</li> </ul> </li> <li>OutputParameters: Output parameters for the action:<ul> <li>Name: The name of the parameter (<code>string</code>).</li> <li>Value: The value of the parameter (<code>string</code>).</li> <li>Description: A description of the parameter (<code>string</code>).</li> </ul> </li> <li>HypertextResources: Additional hypertext resources related to the action.</li> </ul> </li> </ul> </li> </ul>"},{"location":"map/#11-triggers","title":"11. Triggers","text":"<ul> <li>Type: <code>array</code></li> <li>Description: Cron-based triggers for the components.</li> <li>Properties:<ul> <li>Name: The name of the trigger (<code>string</code>).</li> <li>Expression: The cron expression (<code>string</code>).</li> <li>TimeZoneId: The time zone ID for the trigger (<code>string</code>).</li> </ul> </li> </ul>"},{"location":"map/#12-filters","title":"12. Filters","text":"<ul> <li>Type: <code>array</code></li> <li>Description: Filters that define specific conditions for components.</li> <li>Properties:<ul> <li>Name: The name of the filter (<code>string</code>).</li> <li>Value: The value for the filter (<code>string</code>).</li> </ul> </li> </ul>"},{"location":"map/#13-interactwithdesktop","title":"13. InteractWithDesktop","text":"<ul> <li>Type: <code>boolean</code></li> <li>Description: (Windows only) Specifies if the agent running as a service can interact with the desktop.</li> </ul>"},{"location":"map/#required-fields","title":"Required Fields","text":"<p>The following fields are required in the AppControl YAML configuration file:</p> <ul> <li>Name</li> <li>Version</li> <li>Description</li> <li>NbRetry</li> <li>Agents</li> <li>Authentications</li> <li>Components</li> </ul> <p>Below is an example of a minimalist AppControl Hello World artefact in YAML:</p> <pre><code>Name: helloworld\nVersion: v1\nIcon: {}\nAgents:\n    - Name: LOCAL\n      Port: 12567\n      SslProtocol: tls12\nAuthentications:\n    - Name: LOCAL\nComponents:\n    - Name: hello\n      Agent:\n          AgentName: LOCAL\n          AuthentificationName: LOCAL\n      Icon:\n          SystemName: file\n      Group: Hello group\n      Description: Hello World\n      Actions:\n          - Name: check hello\n            Type: check\n            Value: cat hello.txt\n          - Name: start hello\n            Type: start\n            Value: echo hello &gt; hello.txt\n          - Name: stop hello\n            Type: stop\n            Value: rm hello.txt\n          - Name: Say Hello\n            Type: custom\n            Value: echo $(message)\n            InputParameters:\n                - Name: message\n                  Value: Hello\n                  CanEdit: true\n                  Validation: '*'\n</code></pre>"},{"location":"map/#xml-format","title":"XML Format","text":"<p>While the XML format is still supported, it is generally less flexible and more complex than YAML. The XML format is often used for legacy configurations.</p> <p>The XML file typically includes the following key information:</p> <ul> <li> <p>Component Definitions: Each component is described by a set of commands:</p> <ul> <li>Check Command: Mandatory for verifying the component's status.</li> <li>Start Command: Optional, used to start the component.</li> <li>Stop Command: Optional, used to stop the component.</li> <li>Custom Commands: Optional, for executing specific tasks or actions tailored to the component.</li> </ul> </li> <li> <p>Agent List: Specifies the agents responsible for executing the commands for each component.</p> </li> <li> <p>Identity Information: Defines which users are authorized to run the commands for specific components.</p> </li> <li> <p>Scheduling Information: Allows scheduling of start/stop commands for automatic execution at predefined times.</p> </li> </ul> <p>Below is an example of a minimalist AppControl Hello World artefact in XML:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n    &lt;hosts&gt;\n       &lt;!-- The way to join the agent --&gt;\n        &lt;host hostid=\"LOCAL\" host=\"127.0.0.1\" port=\"12567\" sslprotocol=\"tls12\" /&gt;\n    &lt;/hosts&gt;\n    &lt;auths&gt;\n        &lt;!-- Identity of the user executing the commands. If empty, commands inherit from agent credentials --&gt;\n        &lt;auth authid=\"LOCAL\" domain=\"\" password=\"\" user=\"\" /&gt;\n    &lt;/auths&gt;\n    &lt;app name=\"helloworld\" version=\"v1\" retry=\"1\"&gt;\n       &lt;!-- A simple component executing an 'echo command' every minute --&gt;\n        &lt;component name=\"hello\" hostref=\"LOCAL\" authref=\"LOCAL\" redirectoutput=\"true\" checkFrequency=\"60\" type=\"file\"&gt;\n            &lt;action value=\"cat hello.txt\" name=\"check\" /&gt;\n            &lt;action value=\"echo hello &gt; hello.txt\" name=\"enable\" /&gt;\n            &lt;action value=\"rm hello.txt\" name=\"disable\" /&gt;\n            &lt;action value=\"echo $(message)\" commandname=\"echo Action\" name=\"custom\"&gt;\n                &lt;parameters&gt;\n                    &lt;parameter name=\"message\" value=\"Hello\" canedit=\"true\" validation=\"*\" /&gt;\n                &lt;/parameters&gt;\n            &lt;/action&gt;\n        &lt;/component&gt;\n    &lt;/app&gt;\n&lt;/apps&gt;\n\n</code></pre>"},{"location":"map/#xml-tag-descriptions","title":"XML Tag Descriptions","text":""},{"location":"map/#the-apps-tag","title":"The <code>&lt;apps&gt;</code> Tag","text":"<p>The <code>&lt;apps&gt;</code> tag is the root element that contains all the elements of the configuration.</p> <pre><code>&lt;apps&gt;\n    &lt;hosts&gt;...&lt;/hosts&gt;\n    &lt;auths&gt;...&lt;/auths&gt;\n    &lt;app&gt;...&lt;/app&gt;\n    &lt;crontable&gt;...&lt;/crontable&gt;\n&lt;/apps&gt;\n</code></pre>"},{"location":"map/#the-hosts-tag","title":"The <code>&lt;hosts&gt;</code> Tag","text":"<p>The <code>hosts</code> tag groups together a set of <code>host</code> tags that describe the agents used to communicate with the components.</p> Attribute Description host Required Value: string. Name to resolve or IPv4 address of the machine to be contacted on the network port Required Value: integer. Tcp port number to use join the agent. hostid Required Value: string. Mnemonic name to designate the host agent and which will then be used as the value of the hostref attribute in a component tag. sslprotocol Optional Default value is set to tls12. Possible values: ssl, tls, tls12. Note: on most Operating Systems ssl and tls are obsolete"},{"location":"map/#the-auths-tag","title":"The <code>&lt;auths&gt;</code> Tag","text":"<p>The <code>auths</code> tag groups together a set of <code>auth</code> tags that describe the identities used to perform actions on application components. These identities will be utilized by agents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n   &lt;!-- ... --&gt;\n   &lt;auths&gt;\n     &lt;auth authid=\"LOCAL\" domain=\"\" password=\"\" user=\"\" /&gt;\n   &lt;/auths&gt;\n   &lt;!-- ... --&gt;\n&lt;/apps&gt;\n</code></pre> Attribute Description authid Required A mnemonic name used to identify the identity that will be referenced by the <code>authref</code> attribute in a component tag. user Required Can be empty. The username or identity. If this value is empty, the username will default to the one running the agent. password Required Can be empty. Value: string. The user's clear text password for authentication. If both the username and password are empty, the identity will default to the one running the agent. domain Optional Microsoft Windows only. The Windows domain name for authentication. <pre><code>                                                                                              |\n</code></pre>"},{"location":"map/#the-app-tag","title":"The <code>&lt;app&gt;</code> Tag","text":"<p>The <code>app</code> tag defines the application and its version It can also contain a reference to a cron schedule for automatic actions.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n   &lt;!-- ... --&gt;\n   &lt;app name=\"TrainingMap\" version=\"current\" cronref=\"MCO\"&gt;\n       &lt;!-- ... --&gt;\n   &lt;/app&gt;\n   &lt;!-- ... --&gt;\n&lt;/apps&gt;\n</code></pre> Attribute Description name Required Mnemonic name to designate an application version Required . Mnemonic name of the application version. Perhaps in a numbered form \"1.3.6\", named \"current\" or mixed \"1.3.6-Stable\" cronref Optional Reference to a \"crontable\" retry Optional Value: integer. The value of the default number of retries to perform component actions on the application"},{"location":"map/#the-component-tag","title":"The <code>&lt;component&gt;</code> Tag","text":"<p>The <code>component</code> tag defines the individual components of the application and their actions (check, start, stop, custom).</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n   &lt;!-- ... --&gt;\n   &lt;app name=\"TrainingMap\" version=\"current\" cronref=\"MCO\"&gt;\n        &lt;component name=\"File exist\" group=\"TEST\" hostref=\"LOCAL\" authref=\"LOCAL\"&gt;\n            &lt;action name=\"check\" value=\"dir componentFile.txt\" /&gt;\n            &lt;action name=\"enable\" value=\"echo start &gt; componentFile.txt\" /&gt;\n            &lt;action name=\"custom\" visibility=\"Public\" commandname=\"File search\" value=\"dir $(file)\"&gt;\n                &lt;parameters&gt;\n                    &lt;parameter name=\"file\"\n                        description=\"Filename to list\"\n                        value=\"\"\n                        canedit=\"true\"\n                        validation=\"\\S+\"\n                    /&gt;\n                &lt;/parameters&gt;\n            &lt;/action&gt;\n        &lt;/component&gt;\n   &lt;/app&gt;\n   &lt;!-- ... --&gt;\n&lt;/apps&gt;\n</code></pre> Attribute Description name Required Name of the component (should be unique in the application). group Optional Name of the group. Used to group a set of components in the UI. hostref Mandatory Value: string. Reference to the agent (see <code>&lt;hosts&gt;</code> tag). Required if not set on the action. authref Mandatory Value: string. Reference to the agent identity (see <code>&lt;auths&gt;</code> tag). Required if not set on the action. type Optional Used to display an icon on the map. A URL to an image (png, jpeg, or svg) can be set. You can also use one of the following values: browser, cd, chip, data-information, devices, dollar, euro, file, green-thermometer, hdd, memflash, memory, middleware, network, orange-thermometer, pounds, process, service, tools, user, yen. description Optional Value: string. Label of the component in addition to the name. redirectoutput Optional Value: boolean. If set to true, standard output will be parsed to find dynamic messages or dynamic components. checkFrequency Optional Value: integer. Component check cycle frequency (in seconds). The default value is set at the server configuration level. retryNumber Optional Value: integer. Maximum number of retry attempts. displayname Optional Value: string. Display name of an application component, replacing \"name\" in the UI."},{"location":"map/#the-father-tag","title":"The father TAG","text":"<p>The <code>father</code> tag creates a dependency on a component. AppControl's approach is based on the principle that child components have knowledge of their parent(s). Multiple parents for a component are allowed. However, be careful not to create a loop, as it is not allowed and will generate an error during loading.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n   &lt;!-- ... --&gt;\n   &lt;app name=\"TrainingMap\" version=\"current\" cronref=\"MCO\"&gt;\n        &lt;component name=\"File exist\" group=\"TEST\" hostref=\"LOCAL\" authref=\"LOCAL\"&gt;\n            &lt;father&gt;Attribut NAME du COMPOSANT PERE #1&lt;/father&gt;\n            &lt;father&gt;Attribut NAME du COMPOSANT PERE #2&lt;/father&gt;\n            &lt;action name=\"check\" value=\"dir componentFile.txt\" /&gt;\n            &lt;action name=\"enable\" value=\"echo start &gt; componentFile.txt\" /&gt;\n            &lt;action name=\"check\" value=\"del /Q componentFile.txt\" /&gt;\n            &lt;action name=\"custom\" visibility=\"Public\" commandname=\"File search\" value=\"dir $(file)\"&gt;\n                &lt;parameters&gt;\n                    &lt;parameter name=\"file\"\n                        description=\"Filename to list\"\n                        value=\"\"\n                        canedit=\"true\"\n                        validation=\"\\S+\"\n                    /&gt;\n                &lt;/parameters&gt;\n            &lt;/action&gt;\n        &lt;/component&gt;\n   &lt;/app&gt;\n   &lt;!-- ... --&gt;\n&lt;/apps&gt;\n</code></pre>"},{"location":"map/#the-action-tag","title":"The action TAG","text":"<p>The <code>action</code> tag is used to describe four kinds of actions:</p> <ul> <li>check: Periodic verification of the component's state at a specified frequency (in seconds). Only one <code>check</code> action is allowed per component.</li> <li>enable: Starts a component. Only one <code>enable</code> action is allowed per component.</li> <li>disable: Stops a component. Only one <code>disable</code> action is allowed per component.</li> <li>custom: Custom commands executed on demand. There can be 0 to n <code>custom</code> actions per component.</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n   &lt;!-- ... --&gt;\n   &lt;app name=\"TrainingMap\" version=\"current\" cronref=\"MCO\"&gt;\n        &lt;component name=\"File exist\" group=\"TEST\" hostref=\"LOCAL\" authref=\"LOCAL\"&gt;\n            &lt;!-- ... --&gt;\n            &lt;action name=\"check\" value=\"dir componentFile.txt\" /&gt;\n            &lt;action name=\"enable\" value=\"echo start &gt; componentFile.txt\" /&gt;\n            &lt;action name=\"check\" value=\"del /Q componentFile.txt\" /&gt;\n            &lt;action name=\"custom\" visibility=\"Public\" commandname=\"File search\" value=\"dir $(file)\"&gt;\n                &lt;parameters&gt;\n                    &lt;parameter name=\"file\"\n                        description=\"Filename to list\"\n                        value=\"\"\n                        canedit=\"true\"\n                        validation=\"\\S+\"\n                    /&gt;\n                &lt;/parameters&gt;\n            &lt;/action&gt;\n        &lt;/component&gt;\n   &lt;/app&gt;\n   &lt;!-- ... --&gt;\n&lt;/apps&gt;\n</code></pre> Attribute Description name Required Value: Specifies the type of check. Possible values: <code>enable</code>, <code>disable</code>, <code>custom</code>. value Required The command line to execute. retryTime Optional Value: integer. Time in seconds before retrying communication with the agent. commandname Required Display name or identifier of the command. visibility Optional Controls the visibility of this custom action outside of AppControl (in XC Scenario). If set to <code>Public</code>, the AppControl worker will publish this action as a Scenario task. The default is <code>Private</code>, meaning the action will not be published. parameters Optional Used to display an icon on the map. A URL to an image (png, jpeg, or svg) can be set. You can also use one of the following values: browser, cd, chip, data-information, devices, dollar, euro, file, green-thermometer, hdd, memflash, memory, middleware, network, orange-thermometer, pounds, process, service, tools, user, yen. hostref Optional Value: string. Reference to the agent (see <code>&lt;hosts&gt;</code> tag). Required if not set on the component. authref Optional Value: string. Reference to the agent identity (see <code>&lt;auths&gt;</code> tag). Required if not set on the component."},{"location":"map/#the-parameters-tag","title":"The parameters TAG","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n   &lt;!-- ... --&gt;\n   &lt;app name=\"TrainingMap\" version=\"current\" cronref=\"MCO\"&gt;\n        &lt;component name=\"File exist\" group=\"TEST\" hostref=\"LOCAL\" authref=\"LOCAL\"&gt;\n            &lt;!-- ... --&gt;\n             &lt;action name=\"custom\" visibility=\"Public\" commandname=\"File search\" value=\"dir $(file)\"&gt;\n                &lt;parameters&gt;\n                    &lt;parameter name=\"file\"\n                        description=\"Filename to list\"\n                        value=\"\"\n                        canedit=\"true\"\n                        validation=\"\\S+\"\n                    /&gt;\n                &lt;/parameters&gt;\n            &lt;/action&gt;\n        &lt;/component&gt;\n   &lt;/app&gt;\n   &lt;!-- ... --&gt;\n&lt;/apps&gt;\n</code></pre> <p>The <code>parameters</code> tag is used to define the parameters of custom actions. These parameters will be available in the UI.</p> <p>The syntax for variables in AppControl is: <code>$(variableName)</code> Within the <code>parameters</code> tag, several <code>parameter</code> tags can be defined with the following attributes:</p> Attribute Description name Required The name of the variable. description Optional A description of the variable. This description is displayed in the UI. value Required The default value of the variable. canedit Optional Values: <code>True</code> (default) or <code>False</code>. If <code>False</code>, the value cannot be edited in the UI. validation Optional Value: regex. A regular expression applied to validate the value."},{"location":"map/#the-crontable-tag","title":"The crontable TAG","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;apps&gt;\n    &lt;crontable&gt;\n        &lt;cronrules cronid=\"scheduling\"&gt;\n        &lt;trigger name=\"CRON#1\" action=\"stop\" force=\"true\" components=\"A1\" propagate=\"false\" expression=\"0 00 * * * ? *\" /&gt;\n            &lt;trigger name=\"CRON#2\" action=\"start\" force=\"true\" components=\"A1\" propagate=\"true\" expression=\"0 15 * * * ? *\" /&gt;\n            &lt;trigger name=\"customDir\" action=\"custom\" components=\"A1\" customactionname=\"dirAction\" customactionparameters=\"option=c;directory=c:\\temp\"   expression=\"0 0/5 * 1/1 * ? *\" /&gt;\n            &lt;trigger name=\"CRON#3\" action=\"stop\" expression=\"0 0/5 * 1/1 * ? *\" /&gt;\n            &lt;trigger name=\"CRON#3\" action=\"start\" expression=\"0 0/2 * 1/1 * ? *\" /&gt;\n        &lt;/cronrules&gt;\n    &lt;/crontable&gt;\n\n    &lt;app name=\"CronDemo\" version=\"v1\" cronref=\"scheduling\"&gt;\n    &lt;component name=\"A1\" description=\"A1 component\" hostref=\"LOCAL\" authref=\"LOCAL\" &gt;\n            &lt;action value=\"echo demo\" name=\"check\" /&gt;\n            &lt;action value=\"start.sh\" name=\"enable\"  /&gt;\n            &lt;action value=\"stop.sh\" name=\"disable\" /&gt;\n            &lt;action name=\"custom\" commandname=\"Perl version\" value=\"C:\\Strawberry\\perl\\bin\\perl.exe  -$(version)\"&gt;\n                &lt;parameters&gt;\n                    &lt;parameter name=\"version\" value=\"V\" canedit=\"false\" validation=\"*\" /&gt;\n                &lt;/parameters&gt;\n            &lt;/action&gt;\n            &lt;action value=\"dir -$(option)  $(directory)\" visibility=\"public\" commandname=\"dirAction\" name=\"custom\"&gt;\n                &lt;parameters&gt;\n                    &lt;parameter name=\"option\" value=\"c\" canedit=\"false\" validation=\"*\" /&gt;\n                    &lt;parameter name=\"directory\" value=\"c:\\sources\\*\" canedit=\"true\" validation=\"*\" /&gt;\n                &lt;/parameters&gt;\n            &lt;/action&gt;\n        &lt;/component&gt;\n    &lt;/app&gt;\n&lt;/apps&gt;\n</code></pre> <p>You can refer to the Quartz Scheduler documentation for a complete list of allowed cron expressions.</p> <p>As shown in the example above, you can include multiple cron expressions in the same file. You can schedule start/stop actions or custom actions.</p>"},{"location":"map/#built-in-wizards","title":"Built-in wizards","text":""},{"location":"map/#auto-generate-application-from-running-processes","title":"Auto-Generate Application from Running Processes","text":"<p>AppControl includes the ability to retrieve running processes on a computer through its agent. The agent, which runs on the target system (Windows or Linux), scans the machine for all active processes and reports them back to AppControl.</p> <p>In the AppControl wizard, this data is then utilized to allow you to easily create applications (also referred to as \"maps\"). The wizard displays the list of running processes, and you can select the ones you wish to include in your application definition. Once selected, AppControl automatically generates a YAML file that represents the application.</p> <p>The generated application is capable of starting, stopping, and checking the status of the selected processes. This provides a seamless way to monitor and control your applications' critical components without the need for manual configuration, ensuring that you can manage both legacy and modern systems efficiently.</p> <ul> <li>To start the wizard go to Overview/New application and select Discover your infrastructure</li> <li>Select: From Servers and then select your gateway and your agent.</li> </ul> <p> </p>"},{"location":"map/#auto-generate-application-from-azure-tenant","title":"Auto-Generate Application from Azure Tenant","text":"<p>AppControl includes the ability to retrieve and visualize Azure resources from your Azure tenant through its integration with Azure APIs. Using its agent which interacts directly with your Azure environment, AppControl can scan your Azure tenant for all active resources and report them back to AppControl.</p> <p>In the AppControl wizard, this data is utilized to help you easily create applications (also referred to as \"maps\"). The wizard displays a list of your Azure resources, such as virtual machines, databases, and other components, allowing you to select the ones you wish to include in your application definition. Once selected, AppControl automatically generates a YAML file that represents the application based on your Azure infrastructure.</p> <p>The generated application is capable of starting, stopping, and checking the status of the selected Azure resources, providing a seamless way to monitor and control your critical cloud components. This eliminates the need for manual configuration and ensures that you can manage both cloud-native and hybrid environments efficiently.</p> <p>Before starting the wizard, you have the good credentials.</p> <p>To use the Azure discovery feature in AppControl, you will need to create an Azure Service Principal with sufficient permissions to allow AppControl to interact with your Azure resources.</p> <p>Step 1: Create a Service Principal</p> <ol> <li>Open your terminal or command-line interface.</li> <li>Run the following command to create a service principal and assign it the \"Reader\" role (sufficient for discovery and read-only access to resources). It's better to limit the scope to specific resources but it's not mandatory.    Ensure that you replace  with your actual Azure subscription ID: <pre><code>az ad sp create-for-rbac --name \"AppControlServicePrincipal\" --role Reader  --scope /subscriptions/&lt;subscription-id&gt;/resourceGroups/&lt;resource-group-name&gt;\n</code></pre> <ol> <li>Output: The command will return a JSON object containing:</li> </ol> <p>AppId (Client ID) Password (Client secret) Tenant (Tenant ID) Subscription ID (Subscription scope where the role is assigned) Save this information securely as it will be required for configuring AppControl.</p> <p>Step 2: Assign Permissions (OPTIONAL)</p> <p>If you need to limit the service principal's permissions to specific resource groups, or if you need to grant more access (such as managing resources), you can assign additional roles. For example, to restrict access to specific resource groups, use this command:</p> <pre><code>az role assignment create \\\n    --role Reader \\\n    --assignee &lt;AppId&gt; \\\n    --scope /subscriptions/&lt;subscription-id&gt;/resourceGroups/&lt;resource-group-name&gt;\n</code></pre> <p>Step 3: Configure AppControl with the Service Principal Credentials</p> <p>Once you\u2019ve created the Service Principal, you need to provide the credentials to AppControl for authentication.</p> <ol> <li>Navigate to Overview/New application and select Discover your infrastructure.</li> <li>Choose From Azure</li> <li>Enter the Client User Name, Client Password (obtained when creating the Service Principal), Tenant ID, Subscription ID and Tenant ID.</li> </ol> <p>AppControl will use these credentials to authenticate with Azure and retrieve your resources.</p> <p></p> <p>This feature empowers you to visualize and manage your entire Azure infrastructure directly from AppControl, ensuring real-time control over your cloud assets.</p>"},{"location":"openshift/","title":"AppControl Installation Guide for OpenShift","text":""},{"location":"openshift/#1-introduction","title":"1. Introduction","text":"<p>This guide describes the installation process for AppControl on an OpenShift cluster. It covers Helm charts, configuration steps, and verification procedures.</p>"},{"location":"openshift/#2-requirements","title":"2. Requirements","text":""},{"location":"openshift/#21-openshift-cluster","title":"2.1 OpenShift Cluster","text":"<p>Ensure that you have an OpenShift cluster with a dedicated project (namespace) for deploying AppControl.</p> <p>To create the namespace if it does not exist:</p> <pre><code>oc new-project Appcontrol\n</code></pre>"},{"location":"openshift/#22-openshift-ingress-default-router","title":"2.2 OpenShift Ingress (Default Router)","text":"<p>OpenShift includes an Ingress controller by default via its built-in Router (HAProxy). Instead of configuring an additional Ingress controller, we will use OpenShift's native Route system to expose the application.</p>"},{"location":"openshift/#23-sql-server-database","title":"2.3 SQL Server Database","text":"<p>AppControl requires a Microsoft SQL Server database to operate.</p> <ul> <li>Required version: SQL Server 2017 or newer</li> <li> <p>Example connection string (used in <code>appcontrol_values.yaml</code> when deploying with Helm):</p> <p><code>yaml connectionString: &gt;     Server=tcp:MY_SERVER_IP,1433;Initial Catalog=MYDATABASE;     Persist Security Info=False;User ID=USERID;Password=PASSWORD;     MultipleActiveResultSets=False;Encrypt=True;     TrustServerCertificate=False;Connection Timeout=30;</code></p> <p>This connection string must be provided in the appcontrol_values.yaml file before deploying AppControl via Helm.</p> </li> </ul>"},{"location":"openshift/#running-sql-server-in-openshift","title":"Running SQL Server in OpenShift","text":"<pre><code>\u26a0\ufe0f Important Note:\nMicrosoft SQL Server cannot be easily deployed on OpenShift using the official Docker image due to OpenShift-specific constraints (e.g., the requirement for containers to run as non-root users).\n</code></pre> <p>However, if you still want to deploy SQL Server within your OpenShift cluster, Microsoft provides a dedicated approach that is compatible with OpenShift. You can follow the instructions in the official workshop documentation:</p> <p>\ud83d\udd17 Deploy SQL Server on OpenShift \u2013 Microsoft Workshop</p>"},{"location":"openshift/#24-redis","title":"2.4 Redis","text":"<p>AppControl also requires a Redis instance, which it uses for both caching and persistent storage of runtime data.</p> <ul> <li>Example connection string:     <code>redis://USER:PASSWORD@HOST:PORT</code>     Replace <code>YOUR_REDIS_CONNECTION_STRING</code> accordingly.</li> </ul> <p>This connection string will be requested later during the installation process, so make sure you have it ready.</p>"},{"location":"openshift/#installing-redis-quick-start-script","title":"Installing Redis (Quick Start Script)","text":"<p>If you don\u2019t already have a Redis instance available, you can deploy one easily using our helper script.</p> <p>Run the following one-liner to install Redis in your Openshift cluster:</p> <pre><code>REDIS_PASSWORD=yourpassword NAMESPACE=your-namespace \\\nbash &lt;(curl -s https://raw.githubusercontent.com/xcomponent/appcontrol-documentation/refs/heads/main/docs/config/install-redis.sh)\n</code></pre> <p>Make sure your cluster has internet access so that the script can be fetched and executed properly.</p> <p>Notes:</p> <ul> <li> <p>If NAMESPACE is not specified, the current Kubernetes namespace will be used.</p> </li> <li> <p>If REDIS_PASSWORD is not provided, the script will use the default password:     <code>appcontrolpwd</code></p> </li> </ul>"},{"location":"openshift/#redis-connection-from-inside-the-cluster","title":"Redis Connection from Inside the Cluster","text":"<p>Once Redis is installed, you can connect to it from inside the cluster using:</p> <pre><code>redis://default:appcontrolpwd@redis-service:6379\ndefault: the default Redis username\n</code></pre> <p><code>appcontrolpwd</code>: the default password (or the one you specified)</p> <p><code>redis-service</code>: the internal Kubernetes service name (DNS-resolvable by other pods)</p> <p><code>6379</code>: the default Redis port</p> <p>This internal connection string will be used by AppControl during installation.</p>"},{"location":"openshift/#25-rabbitmq","title":"2.5 RabbitMQ","text":"<p>AppControl requires a RabbitMQ instance for message queuing and internal communication.</p>"},{"location":"openshift/#installing-rabbitmq-quick-start","title":"Installing RabbitMQ (Quick Start)","text":"<p>To install RabbitMQ in your Kubernetes/OpenShift cluster without editing any files locally, run:</p> <pre><code>export RABBITMQ_USER=${RABBITMQ_USER:-admin}\nexport RABBITMQ_PASS=${RABBITMQ_PASS:-admin123}\n\nNAMESPACE=$(oc config view --minify --output 'jsonpath={..namespace}')\nNAMESPACE=${NAMESPACE:-default}\nRABBITMQ_USER=$RABBITMQ_USER RABBITMQ_PASS=$RABBITMQ_PASS \\\ncurl -s https://raw.githubusercontent.com/xcomponent/appcontrol-documentation/refs/heads/main/docs/config/rabbitmq.yaml | \\\nenvsubst | oc apply -n \"$NAMESPACE\" -f -\n\n\n</code></pre> <p>\ud83d\udca1 You can omit the variables to use defaults:</p> <p>Username: <code>admin</code> Password: <code>admin123</code></p> <p>This setup includes:</p> <ul> <li> <p>A Secret with credentials (customizable via environment variables)</p> </li> <li> <p>A RabbitMQ Deployment</p> </li> <li> <p>An internal Service for AMQP traffic</p> </li> <li> <p>An OpenShift Route for accessing the Web UI (port 15672)</p> </li> </ul>"},{"location":"openshift/#rabbitmq-connection-from-inside-the-cluster","title":"RabbitMQ Connection from Inside the Cluster","text":"<p>AppControl will connect using:</p> <pre><code>Host: rabbitmq\nPort: 5672\nVirtual Host: /\nUsername: your-username\nPassword: your-password\n</code></pre>"},{"location":"openshift/#26-dns-configuration-for-appcontrol-deployment","title":"2.6 DNS Configuration for AppControl Deployment","text":"<p>AppControl requires two distinct DNS entries to operate:</p> <ul> <li><code>x4b.mycompany.com</code> \u2013 for the X4B core platform</li> <li><code>appcontrol.mycompany.com</code> \u2013 for the AppControl web interface</li> </ul>"},{"location":"openshift/#define-the-primary-domain","title":"\u2705 Define the Primary Domain","text":"<p>In your configuration, you only need to define the main domain (e.g. <code>mycompany.com</code>):</p> <pre><code>export MY_APPCONTROL_DOMAIN=mycompany.com\n</code></pre> <p>The system will automatically derive the necessary subdomains:</p> <ul> <li> <p>x4b.${MY_APPCONTROL_DOMAIN} for the X4B backend</p> </li> <li> <p>appcontrol.${MY_APPCONTROL_DOMAIN} for the AppControl frontend</p> </li> </ul> <p>\ud83d\udca1 This simplifies DNS configuration and ensures consistency.</p>"},{"location":"openshift/#if-you-are-deploying-on-a-different-domain","title":"If You Are Deploying on a Different Domain","text":"<p>If you're deploying AppControl on another domain, make sure that:</p> <ul> <li> <p>x4b. and appcontrol. are correctly configured as DNS records <li> <p>Both entries point to the public IP or ingress controller of your Kubernetes/OpenShift cluster</p> </li>"},{"location":"openshift/#3-appcontrol-platform-installer","title":"3. AppControl Platform Installer","text":"<p>This page explains how to deploy the AppControl platform and its required services using the interactive installation script: <code>install-appcontrol.sh</code>.</p> <p>The script sets up everything automatically, including:</p> <ul> <li>Helm registry authentication</li> <li>Kubernetes namespace creation</li> <li>JWT key generation and secret</li> <li>Redis and RabbitMQ integration</li> <li>SQL Server connection</li> <li>Configuration injection via ConfigMap</li> <li>Helm chart deployment for:<ul> <li><code>x4b-services</code></li> <li><code>appcontrol</code></li> </ul> </li> </ul>"},{"location":"openshift/#requirements","title":"\u2699\ufe0f Requirements","text":"<ul> <li><code>oc</code> (OpenShift CLI)</li> <li><code>helm</code> (Helm 3+)</li> <li><code>openssl</code> (for JWT key generation)</li> <li>Access to the Helm OCI registry (<code>x4bcontainerregistry.azurecr.io</code>)</li> </ul>"},{"location":"openshift/#ssl-configuration","title":"\ud83d\udd10 SSL Configuration","text":"<p>AppControl supports HTTPS access to its web interfaces, and you have two options to enable SSL:</p>"},{"location":"openshift/#option-1-ssl-via-kubernetes-ingress-lets-encrypt","title":"Option 1: SSL via Kubernetes Ingress (Let's Encrypt)","text":"<p>If you are using an Ingress controller (e.g. nginx) inside your cluster:</p> <ul> <li>AppControl is preconfigured to support Let's Encrypt</li> <li>You must create a <code>ClusterIssuer</code> named <code>letsencrypt-issuer</code></li> <li>The certificate will be automatically generated and renewed by <code>cert-manager</code></li> </ul>"},{"location":"openshift/#example-lets-encrypt-clusterissuer-staging","title":"\u2705 Example: Let's Encrypt ClusterIssuer (Staging)","text":"<pre><code>apiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n    name: letsencrypt-issuer\nspec:\n    acme:\n        server: https://acme-staging-v02.api.letsencrypt.org/directory\n        email: your-email@yourdomain.com\n        privateKeySecretRef:\n            name: letsencrypt-account-key\n        solvers:\n            - http01:\n                  ingress:\n                      class: nginx\n</code></pre> <p>\ud83d\udca1 Replace with the production ACME server for production use.</p>"},{"location":"openshift/#option-2-ssl-via-external-gateway-or-load-balancer","title":"Option 2: SSL via External Gateway or Load Balancer","text":"<p>If your architecture includes an external API gateway, reverse proxy, or cloud load balancer (e.g., Azure Front Door, AWS ELB, NGINX outside k8s):</p> <p>You can terminate SSL there</p> <p>Disable TLS in the Helm values:</p> <pre><code>ingress:\n  tls: false\n  sslredirect: false\nThis lets you delegate SSL management to your gateway, while still using AppControl inside the cluster over HTTP.\n</code></pre> <p>Default Ingress Settings in the Script The script generates:</p> <pre><code>ingress:\n    class: nginx\n    tls: true\n    sslredirect: true\n</code></pre> <p>This works out-of-the-box with cert-manager and letsencrypt-issuer. If you're using an external gateway, update these settings before installation or edit appcontrol-values.yaml.</p>"},{"location":"openshift/#inputs-prompted-by-the-script","title":"\ud83e\uddea Inputs Prompted by the Script","text":"Input Description Example Default <code>MY_APPCONTROL_DOMAIN</code> Your domain (base DNS) <code>mycompany.com</code> required Namespace Kubernetes namespace for install <code>appcontrol</code> Current namespace Helm registry credentials Used to authenticate to the OCI Helm registry <code>login / password</code> required SQL Server info Connection details to your SQL database <code>sql.prod.local</code> etc. required Token salt Salt used for JWT generation Random base64 string auto-generated Redis host/port Redis service used by AppControl <code>redis-service:6379</code> <code>redis-service:6379</code> RabbitMQ host/port/vhost/user RabbitMQ messaging broker used by X4B &amp; AppControl <code>rabbitmq</code>, <code>5672</code> Defaults + prompt values Helm chart X4B Service version Version of Helm chart to install <code>40.6.0</code> <code>40.6.0</code> Helm chart Appcontrol version Version of Helm chart to install <code>90.3.0</code> <code>90.3.0</code>"},{"location":"openshift/#generated-files","title":"\ud83d\udcc2 Generated Files","text":"File Purpose <code>x4b-services-values.yaml</code> Values for the <code>x4b-services</code> Helm chart <code>appcontrol-values.yaml</code> Values for the <code>appcontrol</code> Helm chart"},{"location":"openshift/#what-the-script-does","title":"\ud83d\udce6 What the Script Does","text":"<ol> <li>Detects or prompts for a Openshift namespace</li> <li>Logs into the AppControl Helm OCI registry</li> <li>Creates a <code>ConfigMap</code> for AppControl config files</li> <li>Generates RSA keys and creates a JWT <code>Secret</code></li> <li>Generates 2 values files (<code>*.yaml</code>)</li> <li>Installs:<ul> <li><code>appcontrol-services</code> chart (X4B platform)</li> <li><code>appcontrol</code> chart (AppControl interface)</li> </ul> </li> </ol>"},{"location":"openshift/#usage","title":"\ud83d\udfe2 Usage","text":"<pre><code>curl -sLO https://raw.githubusercontent.com/xcomponent/appcontrol-documentation/refs/heads/main/docs/config/install-appcontrol.sh\nchmod +x install-appcontrol.sh\n./install-appcontrol.sh\n</code></pre> <p>Follow the interactive prompts. The deployment takes just a few minutes.</p> <p>\u2705 Result</p>"},{"location":"openshift/#once-installed","title":"\u2705 Once Installed","text":"<p>Depending on whether you enabled TLS during installation:</p>"},{"location":"openshift/#if-tls-was-enabled","title":"\ud83d\udd12 If TLS was enabled:","text":"<ul> <li>AppControl is available at https://appcontrol.mycompany.com</li> <li>X4B backend is available at https://x4b.mycompany.com</li> </ul>"},{"location":"openshift/#if-tls-was-not-enabled","title":"\ud83c\udf10 If TLS was not enabled:","text":"<ul> <li>AppControl is available at http://appcontrol.mycompany.com</li> <li>X4B backend is available at http://x4b.mycompany.com</li> </ul>"},{"location":"openshift/#accessing-the-platform","title":"\ud83d\udc64 Accessing the Platform","text":"<p>After installation is complete, a default administrator account is created automatically:</p> <ul> <li>Username: <code>admin</code></li> <li>Password: <code>KoordinatorAdmin</code></li> </ul> <p>You can log in to the AppControl web interface using this account.</p> <p>\u26a0\ufe0f Important: For security reasons, it is strongly recommended to change the default password after your first login.</p> <p>You can update the password directly from the user settings page inside the AppControl UI.</p> <p>\ud83d\udcce Notes</p> <ul> <li> <p>Redis and RabbitMQ should be running in the cluster or externally accessible.</p> </li> <li> <p>SSL and Ingress settings are pre-configured for a typical nginx setup.</p> </li> <li> <p>Make sure your DNS entries are correctly pointed before accessing the web UI.</p> </li> </ul>"},{"location":"repo/","title":"Git integration","text":"<p>AppControl YAML or XML files can be conveniently stored in a Git repository for version control and collaboration. Additionally, you can display the live status of your application directly in your documentation by adding a markdown badge link. For example:</p> <pre><code>![My App](https://appcontrol.xcomponent.com/core/api/badge?applicationName=MYAPP,v1@myaccount)\n</code></pre> <p>This badge will display the real-time status of your application in your documentation.</p> <p></p>"},{"location":"repo/#automating-application-deployment-with-appcontrol-apis","title":"Automating Application Deployment with AppControl APIs","text":"<p>AppControl provides powerful APIs that allow for automatic deployment of applications through custom scripts. These scripts can be integrated into your CI/CD pipelines or used for ad-hoc deployments. Below is a generic example of a script that loads and deploys an application map (in YAML or XML format) to AppControl.</p> <p>Sample Deployment Script</p> <pre><code>#!/usr/bin/env bash\nset -o errexit\nset -o nounset\n\n# API endpoint for AppControl\nexport API=${APPCONTROL_HOME:-https://appcontrol.xcomponent.com}/core\n\ndebug() {\n    [[ \"${DEBUG:-0}\" != \"0\" ]] &amp;&amp; echo \"$@\"\n}\n\nmain() {\n    # Check if the required parameters are passed\n    if [[ $# -lt 2 ]]; then\n        echo \"Usage: $0 &lt;map-file&gt; &lt;gateway-name&gt;\"\n        exit 1\n    fi\n\n    local mapFile=\"$1\"\n    local agentProxyName=\"$2\"\n    local mapFileContents=$(cat \"$mapFile\")\n\n    # Extract application name and version from the map file (XML or YAML)\n    local mapName=$(grep \"&lt;app name\" \"$mapFile\" | cut -d \"\\\"\" -f2)\n    local mapVersion=$(grep \"&lt;app name\" \"$mapFile\" | cut -d \"\\\"\" -f4)\n    local escapedMapFileContents\n\n    # Check if XML parsing failed (if mapName or mapVersion is empty, fallback to YAML)\n    if [[ -z \"$mapName\" ]] || [[ -z \"$mapVersion\" ]]; then\n        echo \"XML parsing failed or not XML format. Trying YAML...\"\n\n        # Attempt to read the file as YAML using yq\n        mapName=$(yq e '.Name' \"$mapFile\")\n        mapVersion=$(yq e '.Version' \"$mapFile\")\n\n        if [[ -z \"$mapName\" ]] || [[ -z \"$mapVersion\" ]]; then\n            echo \"YAML parsing failed. Please check the file format.\"\n            exit 1\n        fi\n    fi\n\n    # Escape file contents to be used in the JSON payload\n    escapedMapFileContents=$(echo \"$mapFileContents\" | jq -aRs .)\n\n    # Prepare the data payload for the API\n    data=$(jq -n --arg xml \"$escapedMapFileContents\" \\\n                    --arg app \"$mapName\" \\\n                    --arg version \"$mapVersion\" \\\n                    --arg gateway \"$agentProxyName\" \\\n                    '{\n                        Xml: $xml,\n                        Application: $app,\n                        Version: $version,\n                        AgentProxyName: $gateway,\n                        LoadMap: \"true\",\n                        OverWrite: \"true\",\n                        UseDefaultAgent: \"false\"\n                    }')\n\n    echo \"Loading $mapName $mapVersion using gateway $agentProxyName...\"\n\n    # Send the API request\n    curl $API/api/Configuration -X PUT \\\n         --header \"Content-Type: application/json\" \\\n         --header \"Authorization: bearer $AUTH\" \\\n         --data-binary \"$data\" \\\n         --fail\n}\n\nmain \"$@\"\n\n</code></pre> <p>Example of usage</p> <pre><code>./deploy_app.sh myapp.yaml Azure_Gateway\n</code></pre> <p>This script will upload the myapp.yaml file and use the specified gateway (Azure_Gateway).</p>"},{"location":"standalone/","title":"Running AppControl Locally with Docker Compose","text":"<p>This package lets you install and run Invivoo's X4B AppControl software locally on a Windows PC. To install X4B AppControl in standalone under Windows OS, unzip the following file into an installation directory, and move into that directory.</p>"},{"location":"standalone/#appcontrol-license-and-usage-terms","title":"AppControl License and Usage Terms","text":"<p>AppControl is free to use for educational purposes. For production use, please contact Invivoo.</p>"},{"location":"standalone/#installing-appcontrol-locally","title":"Installing AppControl Locally","text":"<p>The AppControl software is delivered as a set of container images, meant to be run inside a container orchestrator such as Kubernetes or Red Hat's OpenShift. Invivoo provides Helm charts for this installation, which is the recommended deployment method for production environments.</p> <p>For a newcomer discovering AppControl for the first time, Invivoo is providing this deployment method, using Docker Compose, to make it easy to quickly set up an AppControl instance locally, on your laptop, and immediately start exploring its possibilities.</p> <p>AppControl includes a gateway and agents that will let you manage any system, local or remote, from this local instance. Conversely, remote workstations will also be able to access and use this instance, meaning the AppControl web-based UI will be accessible from every machine on your network.</p> <p>Note that this setup is NOT recommended for production deployments.</p>"},{"location":"standalone/#requirements","title":"Requirements","text":"<p>You will need Docker Desktop on your PC. Invivoo recommends choosing WSL 2 over Hyper-V for the Linux virtualization (see installation instructions below).</p> <p>You will need at least 16 Gb of RAM and 5 Gb of available disk space.</p>"},{"location":"standalone/#installation-instructions","title":"Installation Instructions","text":""},{"location":"standalone/#docker-desktop","title":"Docker Desktop","text":"<p>To install the latest version of Docker Desktop, follow the instructions on their website.</p> <p>In the System Requirements section, choose WSL 2 backend, and follow the instructions from Microsoft to enable the feature and install WSL.</p>"},{"location":"standalone/#appcontrol-with-docker-compose","title":"AppControl with Docker Compose","text":"<p>Docker Compose is a tool for defining and running multi-container Docker applications. Invivoo provides the <code>appcontrol.yml</code> file to configure AppControl's services. This lets you create and start all the services with a single command.</p> <p>Make sure that Docker Desktop is started. Open a command line tool (a normal one, administrator rights are not required), and run the following command:</p> <pre><code>docker-compose -f appcontrol.yml -f appcontrol-images.yml up -d\n</code></pre> <p>The command will start by retrieving all the required container images from Invivoo's DockerHub repository, this may take a few minutes. After that, the containers are started with the <code>docker run</code> command. Subsequent runs will reuse the locally-stored images.</p> <p>When the command has finished executing, you should see an output similar to this:</p> <pre><code> - Network appcontrol-compose_default                  Created                            0.8s\n - Container appcontrol-compose-rabbit-1               Started                            8.4s\n - Container appcontrol-compose-gateway-1              Started                            8.5s\n - Container appcontrol-compose-agentdebian-1          Started                            8.9s\n - Container appcontrol-compose-login-1                Started                            8.9s\n - Container appcontrol-compose-sql-1                  Started                            9.0s\n - Container appcontrol-compose-redis-1                Started                            8.3s\n - Container appcontrol-compose-webapp-1               Started                            8.8s\n - Container appcontrol-compose-notification-1         Started                           12.6s\n - Container appcontrol-compose-api-1                  Started                           15.8s\n - Container appcontrol-compose-configvalidator-1      Started                           12.2s\n - Container appcontrol-compose-agentmanager-bridge-1  Started                           15.3s\n - Container appcontrol-compose-dbaccess-1             Started                           13.7s\n - Container appcontrol-compose-scheduler-1            Started                           14.5s\n - Container appcontrol-compose-launcher-1             Started                           14.8s\n - Container appcontrol-compose-launcher-dispatcher-1  Started                           10.3s\n - Container appcontrol-compose-statistics-1           Started                           14.4s\n - Container appcontrol-compose-agentmanager-1         Started                           15.2s\n - Container appcontrol-compose-agentstatus-1          Started                           15.3s\n - Container appcontrol-compose-apps-1                 Started                           17.3s\n - Container appcontrol-compose-authentication-1       Started                           21.0s\n</code></pre> <p>The AppControl services are up and running.</p>"},{"location":"standalone/#using-the-web-interface","title":"Using the Web Interface","text":"<p>In your web browser, navigate to http://localhost:4000 to access the AppControl webapp. Use the following credentials to login:</p> <ul> <li>login: <code>admin</code></li> <li>password: <code>KoordinatorAdmin</code></li> </ul>"},{"location":"standalone/#getting-help","title":"Getting Help","text":"<p>Once you're logged into AppControl, you can access the online documentation through the help button (?) on the top right of the screen:</p> <p></p> <p>The dropdown menu also lets you contact Invivoo support through email, and join our Slack channel for access to the development team.</p>"},{"location":"standalone/#test-appcontrol-with-the-helloworld-map","title":"Test AppControl with the Helloworld map","text":"<p>The installation package includes a sample AppControl map to help you get started. In the webapp, import the sample map by clicking on the New application button and uploading the file called <code>hellowworld,v1.xml</code>.</p> <p>Here's a tutorial video to help you get started: Helloworld tutorial</p>"},{"location":"standalone/#stop-uninstall-appcontrol","title":"Stop / Uninstall AppControl","text":"<p>Run the following command to stop AppControl:</p> <pre><code>docker-compose -f appcontrol.yml -f appcontrol-images.yml stop\n</code></pre> <p>If you want to start again, run the following command:</p> <pre><code>docker-compose -f appcontrol.yml -f appcontrol-images.yml up -d\n</code></pre> <p>To completely remove AppControl, run the following command:</p> <pre><code>docker-compose -f appcontrol.yml -f appcontrol-images.yml rm\n</code></pre>"},{"location":"x4bcli/","title":"Introduction","text":"<p>To fully utilize AppControl's capabilities with on-premises infrastructure, the X4B Gateway is required. The gateway facilitates secure communication between your on-premises agents and the AppControl SaaS platform. This allows for real-time monitoring and control of your local applications, even when agents are deployed across diverse environments.</p> <p>X4B Gateway Overview The X4B Gateway acts as a secure link, enabling AppControl to interact with agents deployed on your local infrastructure. The gateway ensures that actions, incidents, and monitoring data are reliably communicated between the agents and the SaaS platform.</p> <p>Agent Deployment Agents can be deployed anywhere within your Information System (I.S.) to manage and monitor your local applications. One of the key benefits of the AppControl agent architecture is that agents do not require direct internet access. The agents communicate with the X4B Gateway, which handles secure data transfer to the AppControl SaaS platform.</p> <p>Getting Started with Agents To begin using agents in your local infrastructure, please refer to the Agents Installation section for step-by-step instructions on installing agents on Windows and Linux environments.</p> <p>Please refer to the Agents Installation section for detailed installation instructions.</p> <p></p> <p>Thanks to the X4B Gateway, you can deploy your applications in the AppControl Cloud Platform while keeping agents deployed on-premises.</p>"},{"location":"x4bcli/#quick-deployment-of-agents-and-gateways-windows-and-macos","title":"Quick Deployment of Agents and Gateways (Windows and macOS)","text":"<p>For both Windows and macOS, there is a quick and efficient way to deploy both agents and the X4B Gateway at the same time. This process requires administrative permissions and will prompt the user to log in to the SaaS platform to link the gateway with their user account.</p>"},{"location":"x4bcli/#windows-deployment","title":"Windows Deployment","text":"<p>To deploy the agent and gateway on Windows, use the following PowerShell script:</p> <pre><code>irm https://raw.githubusercontent.com/xcomponent/appcontrol-documentation/main/docs/en/scripts/appcontrolinstall.ps1 | iex\n</code></pre> <p>This script will:</p> <ol> <li>Install the agent and the X4B Gateway on your local machine.</li> <li>Prompt you to log in to the AppControl SaaS platform during installation to link the gateway with your user account.</li> </ol>"},{"location":"x4bcli/#macos-deployment","title":"macOS Deployment","text":"<p>To deploy the agent and gateway on macOS, use the following bash script:</p> <pre><code>bash -c \"$(curl -fsSL https://raw.githubusercontent.com/xcomponent/appcontrol-documentation/main/docs/en/scripts/appcontrolinstallmac.sh)\"\n</code></pre> <p>This script will:</p> <ol> <li>Install the agent and the X4B Gateway on your macOS system.</li> <li>Prompt you to log in to the AppControl SaaS platform during installation to link the gateway with your user account.</li> </ol> <p>Important Notes:</p> <ul> <li>Administrative permissions are required to execute these scripts.</li> <li>The user will be prompted to log in during the installation process to complete the linkage between the gateway and the user account in the AppControl SaaS platform.</li> </ul> <p>For more detailed steps on the installation and troubleshooting, please refer to the Agents Installation section.</p>"},{"location":"x4bcli/#x4b-gateway-custom-installation","title":"X4B Gateway custom installation","text":"<p>Gateways are available for Windows and Docker. For Windows, the .NET framework is required. The X4B Gateway is necessary to take advantage of agents deployed on-premises.</p> <p>Agents can be deployed anywhere in your infrastructure. They do not need internet access.</p> <p>Please refer to the agents installation section for detailed instructions on agent installation.</p>"},{"location":"x4bcli/#latest-available-versions","title":"Latest Available Versions","text":"Operating System Format Latest Version Microsoft Windows zip Windows Gateway Zip N/A docker <code>docker pull xcomponent/x4b-gateway:latest</code>"},{"location":"x4bcli/#how-does-it-work","title":"How does it work ?","text":"<p>The first step is to log in and navigate to this page: AppControl.</p> <ol> <li> <p>Click on Register New Gateway </p> </li> <li> <p>Provide a name for your gateway and confirm.</p> </li> <li> <p>Once your gateway is created, an Access Key and a Secret Access Key will be generated. </p> </li> <li> <p>Now, you're ready to install the X4B Gateway. Please refer to the documentation below for the installation procedure.</p> </li> <li> <p>Since the X4B Gateway communicates with agents, you'll need to install at least one agent.</p> </li> <li> <p>Once your X4B Gateway and agent are up and running, you\u2019re ready to deploy a new application.</p> </li> </ol>"},{"location":"x4bcli/#retrieving-x4b-gateway-credentials","title":"Retrieving X4B Gateway Credentials","text":"<p>The first step is to retrieve the X4B Gateway credentials. Navigate to the Gateway page and note the following information:</p> <ul> <li>Name</li> <li>Access Key</li> <li> <p>Secret Access Key</p> <p></p> </li> </ul>"},{"location":"x4bcli/#microsoft-windows-platform-installation","title":"Microsoft Windows Platform Installation","text":"<p>On Microsoft Windows, the .NET Framework 4.7.2 or later is required.</p> <p>In most cases, it is already installed. Unzip the following file.</p> <p>The quickest method is to execute the following command in a PowerShell window with administrative permissions. This command will install the gateway and the agent as Windows services:</p> <pre><code>irm https://raw.githubusercontent.com/xcomponent/appcontrol-documentation/main/scripts/appcontrolinstall.ps1 | iex\n</code></pre> <p>Note:</p> <pre><code>For the other installation procedures mentioned above, we recommend using cmd.exe as the shell to install the gateway and the agent. We do not support installation via PowerShell.\n</code></pre> <p>On a prompt (cmd.exe), execute the following command line. Replace MY_ACCESS_KEY, MY_SECRET_ACCESSKEY and MY_GATEWAY_NAME with the suitable values.</p> <pre><code>c:\\x4b&gt; x4b run gateway -a MY_ACCESS_KEY -k MY_SECRET_ACCESSKEY -p MY_GATEWAY_NAME [-l Trace]\n</code></pre> <p>You can also, set the following environment variables:</p> <pre><code>c:\\x4b&gt; set X4B_ACCESS_KEY = MY_ACCESS_KEY\nc:\\x4b&gt; set X4B_SECRET_ACCESS_KEY = MY_SECRET_ACCESSKEY\nc:\\x4b&gt; set X4B_PROXY_NAME = MY_GATEWAY_NAME\n</code></pre> <p>If the configuration is correct, you should see the following lines in the terminal:</p> <pre><code>  __  ______ ___  __  __ ____   ___  _   _ _____ _   _ _____\n \\ \\/ / ___/ _ \\|  \\/  |  _ \\ / _ \\| \\ | | ____| \\ | |_   _|\n  \\  / |  | | | | |\\/| | |_) | | | |  \\| |  _| |  \\| | | |\n  /  \\ |__| |_| | |  | |  __/| |_| | |\\  | |___| |\\  | | |\n /_/\\_\\____\\___/|_|  |_|_|    \\___/|_| \\_|_____|_| \\_| |_|\n\n\nXComponent For Business by Invivoo Software - 2021\n25/02/2021 09:15:20# X4B Gateway is up and running... (Press Ctrl+C to exit)\n25/02/2021 09:15:21# Waiting for websocket connection\n25/02/2021 09:15:39# HeartBeat successfully published\n25/02/2021 09:15:39# Websocket connection established\n\n</code></pre>"},{"location":"x4bcli/#microsoft-windows-service-installation","title":"Microsoft Windows service Installation","text":"<p>In a prompt with administrative permissions:</p> <pre><code>c:\\x4b&gt; x4b install -servicename x4bGatewayServiceName  -server \"https://appcontrol.xcomponent.com/core\" -loglevel \"Trace\" -access \"myAccesToken\" -proxyname \"myGatewayName\" -secret \"mySecretToken\"\n</code></pre> <p>The following parameters are specific to the gateway:</p> <p>-server \"https://appcontrol.xcomponent.com/core\" -loglevel \"Trace\" -access \"myAccesToken\" -proxyname \"myGatewayName\" -secret \"mySecretToken\"</p>"},{"location":"x4bcli/#docker-installation","title":"Docker Installation","text":"<p>The docker image is available on docker hub: x4b-gateway</p> <pre><code>docker run -e X4B_ACCESS_KEY=MY_ACCESS_KEY -e X4B_SECRET_ACCESS_KEY=MY_SECRET_ACCESSKEY -e X4B_PROXY_NAME=MY_GATEWAY_NAME xcomponent/x4b-gateway:latest\n</code></pre> <p>If the configuration is correct, you should observe the following lines in the terminal:</p> <pre><code>  __  ______ ___  __  __ ____   ___  _   _ _____ _   _ _____\n \\ \\/ / ___/ _ \\|  \\/  |  _ \\ / _ \\| \\ | | ____| \\ | |_   _|\n  \\  / |  | | | | |\\/| | |_) | | | |  \\| |  _| |  \\| | | |\n  /  \\ |__| |_| | |  | |  __/| |_| | |\\  | |___| |\\  | | |\n /_/\\_\\____\\___/|_|  |_|_|    \\___/|_| \\_|_____|_| \\_| |_|\n\n\nXComponent For Business by Invivoo Software - 2021\n25/02/2021 09:15:20# X4B Proxy is up and running... (Press Ctrl+C to exit)\n25/02/2021 09:15:21# Waiting for websocket connection\n25/02/2021 09:15:39# HeartBeat successfully published\n25/02/2021 09:15:39# Websocket connection established\n\n</code></pre>"},{"location":"x4bcli/#display-environment-variables","title":"Display environment variables","text":"<pre><code>c:\\x4b&gt;x4b env\n</code></pre>"},{"location":"x4bcli/#install-and-run-the-gateway-with-docker-and-builtin-command-of-the-gateway","title":"Install and run the gateway with docker and builtin command of the gateway","text":"<pre><code>c:\\x4b&gt;x4b run docker -a|--accesskey &lt;accesskey&gt; -k|--secretaccesskey &lt;secretaccesskey&gt; -p|--gatewayname &lt;gatewayname&gt; [-l|--loglevel &lt;loglevel&gt;] [-i|--imagetag &lt;imagetag&gt;] [-u|--urlserver &lt;urlserver&gt;]\n</code></pre>"},{"location":"x4bcli/#remove-appcontrol-gateway-service-from-the-workstation","title":"Remove Appcontrol Gateway service from the workstation","text":"<pre><code>c:\\x4b&gt;x4b uninstall -servicename x4bGatewayServiceName\n</code></pre>"},{"location":"x4bcli/#remove-appcontrol-gateway-container-running-with-docker","title":"Remove Appcontrol Gateway container running with Docker","text":"<pre><code>c:\\x4b&gt;x4b uninstall docker -c|--containername MY_GATEWAY_NAME\n</code></pre>"},{"location":"x4bcli/#display-help","title":"Display Help","text":"<p>x4b -v|--version x4b [command] -h x4b subcommand [command] -h|--help</p> <pre><code>c:\\x4b&gt;x4b -h // display list of commands available\nc:\\x4b&gt;x4b run -h // display help for command run\nc:\\x4b&gt;x4b run docker -h //display help for the subcommand\nc:\\x4b&gt;x4b run gateway -h // display help for the subcommand\nc:\\x4b&gt;x4b uninstall docker -h // display help for this specific command\n</code></pre>"},{"location":"x4bcli/#check-appcontrols-agent-communication","title":"Check AppControl's Agent Communication","text":"<p>The gateway can also be useful for checking if the agent is up and running. Agents can be deployed on the same computer as the gateway or elsewhere on the network.</p> <p>For example, if you have deployed an agent on the host <code>myhost</code> and the gateway is deployed elsewhere in the network, open <code>cmd.exe</code> and enter the following command:</p> <pre><code>c:\\x4b&gt;x4b run interactive --host myhost\n</code></pre> <p>This is the list of allowed parameters:</p> Parameters Description Example --host Agent host name x4b run interactive --host MYHOST --port Agent port value x4b run interactive --host MYHOST --port 12345 --ssl Ssl protocol: Tls, Tls12, Tls13 x4b run interactive --host MYHOST --port 12345 --ssl Tls12 --loglevel Log Level: Error, Info, Trace x4b run interactive --host MYHOST --port 12345 --ssl Tls12 --loglevel Error <p>If the gateway can't reach the agent, you will obtain the following output:</p> <pre><code>c:\\x4b&gt;x4b run interactive --host myhost\nLaunching gateway in interactive mode...\n __  ______ ___  __  __ ____   ___  _   _ _____ _   _ _____\n \\ \\/ / ___/ _ \\|  \\/  |  _ \\ / _ \\| \\ | | ____| \\ | |_   _|\n  \\  / |  | | | | |\\/| | |_) | | | |  \\| |  _| |  \\| | | |\n  /  \\ |__| |_| | |  | |  __/| |_| | |\\  | |___| |\\  | | |\n /_/\\_\\____\\___/|_|  |_|_|    \\___/|_| \\_|_____|_| \\_| |_|\n\n\nXComponent For Business by Invivoo Software - 2023\n\n12/09/2023 17:08:52# X4B Gateway is up and running... (Press Ctrl+C to exit)\n\n12/09/2023 17:08:55# Connection to agent fails - Retrying in few seconds...\n</code></pre> <p>If the gateway is able to reach the agent, you will obtain the following output:</p> <pre><code>C:\\&gt;x4b run interactive --host localhost\nLaunching gateway in interactive mode...\n __  ______ ___  __  __ ____   ___  _   _ _____ _   _ _____\n \\ \\/ / ___/ _ \\|  \\/  |  _ \\ / _ \\| \\ | | ____| \\ | |_   _|\n  \\  / |  | | | | |\\/| | |_) | | | |  \\| |  _| |  \\| | | |\n  /  \\ |__| |_| | |  | |  __/| |_| | |\\  | |___| |\\  | | |\n /_/\\_\\____\\___/|_|  |_|_|    \\___/|_| \\_|_____|_| \\_| |_|\n\n\nXComponent For Business by Invivoo Software - 2023\n\n12/09/2023 17:11:53# X4B Gateway is up and running... (Press Ctrl+C to exit)\n\n12/09/2023 17:11:54# Connection to agent established\n\n12/09/2023 17:11:54#\n***************************************\nAgent configuration:\nVersion=26.0\nPlatform=Windows\nCpu Usage=15%\nnetworkAddress=0.0.0.0\nport=12567\nlogdirectory=C:\\tools\\appcontrol\\xcAgent-binary\\./logs\ntempdirectory=C:\\Windows\\TEMP\nmaxlogsizeinmo=5\nnbdaystodeletelogs=10\nredirecterroutput=1\nexecutionthreshold=200\nloglevel=TRACE\ntrustedservers=\nsslprotocol=tls12\nsshkeydirectory\nshell=\nignoretrustedservers=false\nserviceaccount=\nwindows Interpreter=C:\\Windows\\system32\\cmd.exe\n\n***************************************\n\nappControlAgent@localhost %\n</code></pre> <p>The gateway is able to reach both Linux and Windows agents.</p> <p>Once connected, you can execute commands on the agent's host. For example, you can use <code>cd</code>, <code>dir</code>, <code>more</code> for Windows, or <code>pwd</code>, <code>ls</code>, <code>cat</code> for Linux.</p> <p>The commands are executed by the default shell, which is <code>cmd.exe</code> for Windows and <code>sh</code> or <code>bash</code> for Linux.</p> <p>Example with a Windows agent:</p> <pre><code>appControlAgent@localhost % dir\n\n R\u00e9pertoire de C:\\tmp\\test\\xcAgent-binary-Win32\n\n12/09/2023  17:31    &lt;DIR&gt;          .\n12/09/2023  17:31    &lt;DIR&gt;          ..\n11/09/2023  14:15               940 config.dat\n11/09/2023  14:31                87 install.bat\n26/03/2018  23:45         2?094?592 libcrypto-1_1.dll\n26/03/2018  23:45           375?808 libssl-1_1.dll\n12/09/2023  17:32    &lt;DIR&gt;          logs\n26/03/2018  23:45           970?912 msvcr120.dll\n11/09/2023  14:29           953?856 xcAgent.exe\n               6 fichier(s)        4?396?195 octets\n               3 R?p(s)  96?394?911?744 octets libres\n\nappControlAgent@localhost C:\\tmp\\test\\xcAgent-binary-Win32% powershell -c cat config.dat\n\n12/09/2023 17:35:25# &lt;!-- XComponent APP Control Agent Configuration file --&gt;\n&lt;config&gt;\n  &lt;item key=\"generatebatch\" value=\"false\" /&gt;\n  &lt;item key=\"windowsinterpreter\" value=\"%ComSpec%\" /&gt;\n  &lt;item key=\"networkAddress\" value=\"0.0.0.0\" /&gt;\n  &lt;item key=\"port\" value=\"12567\" /&gt;\n  &lt;item key=\"logdirectory\" value=\"./logs\" /&gt;\n  &lt;item key=\"tempdirectory\" value=\"%TEMP%\" /&gt;\n  &lt;item key=\"maxlogsizeinmo\" value=\"5\" /&gt;\n  &lt;item key=\"nbdaystodeletelogs\" value=\"10\" /&gt;\n  &lt;item key=\"redirecterroutput\" value=\"true\" /&gt;\n  &lt;item key=\"logToStandardOutput\" value=\"true\" /&gt;\n  &lt;item key=\"executionthreshold\" value=\"200\" /&gt;\n  &lt;item key=\"loglevel\" value=\"TRACE\" /&gt; &lt;!-- NONE, INFO, TRACE, ERROR --&gt;\n  &lt;item key=\"trustedservers\" value=\"\" /&gt;\n  &lt;item key=\"ignoretrustedservers\" value=\"false\" /&gt;\n  &lt;item key=\"sslprotocol\" value=\"tls12\" /&gt; &lt;!-- ssl, tls, tls12, tls13 --&gt;\n  &lt;item key=\"sshkeydirectory\" value=\"\" /&gt;  &lt;!-- Linux Only --&gt;\n  &lt;item key=\"shell\" value=\"\" /&gt;\n&lt;/config&gt;\n\nappControlAgent@localhost C:\\tmp\\test\\xcAgent-binary-Win32%\n</code></pre> <p>Example with debian's agent:</p> <pre><code>appControlAgent@macbook % ls\n\n12/09/2023 17:36:56# config.dat\nconfig_env.dat\nlibs\nlogs\nrun.sh\ntmp\nxcAgent.bin\n\nappControlAgent@macbook /usr/src/app/xcagent% cat config.dat\n\n12/09/2023 17:37:23# &lt;!-- XComponent APP Control Agent Configuration file --&gt;\n&lt;config&gt;\n  &lt;item key=\"networkAddress\" value=\"0.0.0.0\" /&gt;\n  &lt;!--TCP listening port of the agent --&gt;\n  &lt;item key=\"port\" value=\"12567\" /&gt;\n  &lt;item key=\"generatebatch\" value=\"true\" /&gt;\n  &lt;!--Logs and Tmp directories--&gt;\n  &lt;item key=\"logdirectory\" value=\"logs\" /&gt;\n  &lt;item key=\"tempdirectory\" value=\"tmp\" /&gt;\n  &lt;item key=\"maxlogsizeinmo\" value=\"5\" /&gt;\n  &lt;item key=\"nbdaystodeletelogs\" value=\"10\" /&gt;\n   &lt;item key=\"redirecterroutput\" value=\"true\" /&gt;\n  &lt;item key=\"executionthreshold\" value=\"50\" /&gt;\n   &lt;item key=\"logToStandardOutput\" value=\"true\" /&gt;\n  &lt;item key=\"loglevel\" value=\"TRACE\" /&gt; &lt;!-- NONE, INFO, TRACE, ERROR --&gt;\n   &lt;!-- IP address of SSH serveur (unix/linux) --&gt;\n  &lt;item key=\"sshhost\" value=\"127.0.0.1\" /&gt;\n  &lt;!-- IP Address or DNS Names of AC2 servers authorized to communicate with the agent --&gt;\n  &lt;item key=\"trustedservers\" value=\"\" /&gt;\n  &lt;item key=\"sslprotocol\" value=\"tls12\" /&gt;  &lt;!-- ssl, tls, tls12 --&gt;\n  &lt;item key=\"sshkeydirectory\" value=\"\" /&gt;  &lt;!-- Linux Only --&gt;\n  &lt;item key=\"shell\" value=\"\" /&gt;\n&lt;/config&gt;\nappControlAgent@macbook /usr/src/app/xcagent%\n</code></pre>"},{"location":"Getting%20Started/","title":"Get Started","text":"<ul> <li>Go to the XComponent AppControl website.</li> <li>Log in using a social provider</li> <li>You're done! You can now get started with AppControl</li> </ul> <p>In the example section, copy the following link to the demo application: demo application.</p> <p>On the AppControl website, go to the Import Application and paste the link of the demo application.</p> <p>Follow the wizard (clicking on 'Next' button). In the 'Gateway' tab select 'X4B SaaS'. On the last tab click on 'Import'.</p> <p></p> <p>Go the 'Overview', and select the helloworld application by clicking on the checkbox. Then click on the load button. </p> <p>Next, click on the 'Architecture' button:</p> <p></p> <p>Using, the command bar, you can now start/stop the Hello World application with ease. </p>"},{"location":"Getting%20Started/appcontrol_worker/","title":"Contents","text":"<p>This document describes how to use AppControl to execute a script or program as a task in XC Scenario. It shows how to define the script invocation in an AppControl map, how to test it directly from AppControl, and finally how to use it from Scenario.</p>"},{"location":"Getting%20Started/appcontrol_worker/#benefits-of-using-appcontrol","title":"Benefits of using AppControl","text":"<p>There are many advantages to running scripts through AppControl, as opposed to running them directly from a worker task:</p> <ul> <li> <p>the use of an AppControl agent for execution makes it easy to run scripts on   remote machines, without requiring the script author to manage remote   connections and logins himself</p> </li> <li> <p>executions through AppControl will benefit from monitoring and supervision by   the production support team</p> </li> <li> <p>defining script calls in an AppControl map allows for better tracking and   management of the script code base</p> </li> </ul>"},{"location":"Getting%20Started/appcontrol_worker/#pre-requisites","title":"Pre-requisites","text":"<p>This document assumes that you have access to a working X4B installation, either Invivoo's SaaS platform, or an X4B platform deployed on your premises.</p> <p>This includes XC Scenario, XC AppControl, and an AppControl worker (detailed below) deployed and configured to interact with this AppControl instance. Contact the administrator of your X4B platform to make sure that all the required components are available and properly configured.</p>"},{"location":"Getting%20Started/appcontrol_worker/#appcontrol-worker","title":"AppControl Worker","text":"<p>The AppControl worker is a standalone program that acts as a worker program for Scenario:</p> <ul> <li>it publishes a catalog of tasks</li> <li>it polls the task queue for tasks to execute</li> <li>it runs tasks and posts task statuses</li> </ul> <p>Unlike other worker programs that implement their own tasks, the AppControl worker:</p> <ul> <li>gets its list of tasks from custom actions in AppControl maps</li> <li>runs tasks by calling custom actions that get executed by an AppControl agent</li> </ul> <p>The AppControl worker must be configured to communicate with an AppControl server through a gateway, which is defined inside AppControl, and is associated with a specific AppControl user.</p>"},{"location":"Getting%20Started/appcontrol_worker/#defining-scripts-for-the-appcontrol-worker","title":"Defining scripts for the AppControl worker","text":"<p>Scripts that are meant to be used with the AppControl worker need to be defined inside an AppControl map, as custom actions attached to some AppControl component.</p>"},{"location":"Getting%20Started/appcontrol_worker/#custom-actions","title":"Custom actions","text":"<p>A custom action is defined by an <code>action</code> element (inside a <code>component</code> element) with a <code>name=\"custom\"</code> attribute. Other important attributes are <code>commandname</code>, which lets you identify each custom action, and <code>value</code>, which holds the actual command to execute.</p> <p>The contents of the <code>value</code> attribute are sent to the AppControl agent for execution, so the platform where the agent is running determines the actual shell script language to use, Windows command/batch script or linux/unix-like shell script.</p> <p>The <code>action</code> element can have <code>parameters</code> and <code>outputParameters</code> sub-elements, for input and output parameters, respectively.</p> <p>The <code>action</code> element also has a <code>visibility</code> attribute, which controls whether the action is accessible from outside AppControl or not. The AppControl worker only retrieves public tasks, so if a custiom action is to be used with Scenario, it is mandatory to specify <code>visibility=\"public\"</code>.</p> <p>See the AppControl map documentation for more details.</p>"},{"location":"Getting%20Started/appcontrol_worker/#example","title":"Example","text":"<p>The following XML snippet is an excerpt from an AppControl map that defines a component named <code>\"comp\"</code> (you can find the map file here). This component has a <code>check</code> action (mandatory) and two custom actions named <code>calc</code> and <code>prod_div</code>.</p> <pre><code>&lt;component name=\"comp\" description=\"Script execution component\" hostref=\"LOCAL\" authref=\"LOCAL\" redirectoutput=\"false\" type=\"file\"&gt;\n    &lt;action value=\"echo 1\" name=\"check\" /&gt;\n\n    &lt;action value=\"C:\\a\\bin\\calc_script.cmd $(arg)\" commandname=\"calc\" name=\"custom\" visibility=\"public\"&gt;\n        &lt;parameters&gt;\n            &lt;parameter name=\"arg\" value=\"\" canedit=\"true\" validation=\"*\" /&gt;\n        &lt;/parameters&gt;\n    &lt;/action&gt;\n\n    &lt;action value=\"py c:\\a\\bin\\pycalc.py $(operand1) $(operand2)\" commandname=\"prod_div\" name=\"custom\" visibility=\"public\"&gt;\n        &lt;parameters&gt;\n            &lt;parameter name=\"operand1\" canedit=\"true\" validation=\"\\d+\" /&gt;\n            &lt;parameter name=\"operand2\" canedit=\"true\" validation=\"\\d+\" /&gt;\n        &lt;/parameters&gt;\n        &lt;outputParameters&gt;\n            &lt;parameter name=\"product\" /&gt;\n            &lt;parameter name=\"division\" /&gt;\n        &lt;/outputParameters&gt;\n    &lt;/action&gt;\n\n&lt;/component&gt;\n</code></pre> <p>The <code>calc</code> action has a single input parameter named <code>arg</code>, defined in the <code>parameters/parameter</code> element, and referenced with the <code>$(arg)</code> inside the <code>value</code> attribute. This action will run the Windows command line file found at <code>C:\\a\\bin\\calc_script.cmd</code> on the agent's machine, passing it the value of the <code>arg</code> parameter (script file here).</p> <p>The <code>prod_div</code> action has both input and output parameters. It runs a python script with two input parameters, calculating the product and division of these two operands, and returning those two values. The <code>outputParameters</code> element is used to list the names of the return values, so they can be added to the task's description in the Scenario task catalog, and also identified in the script's output stream (see A script with output parameters below).</p>"},{"location":"Getting%20Started/appcontrol_worker/#running-custom-actions-in-appcontrol","title":"Running custom actions in AppControl","text":"<p>Once the custom actions have been defined in the map file, as above, the map must be imported into AppControl, using the New button in the UI. Please refer to the AppControl documentation if you need more information on how to use the AppControl UI.</p> <p>When the <code>Architecture</code> tab is chosen to display the map's graph, the components from the map are shown, and any custom actions defined on them will be found on a dropdown menu accessible through a right-click:</p> <p></p>"},{"location":"Getting%20Started/appcontrol_worker/#a-simple-script","title":"A simple script","text":"<p>If we pick the <code>calc</code> action, a dialog box (on the left) shows the command line that will be executed, as well as the arguments that are expected (in this case, the single parameter <code>arg</code>). Enter a value for the argument, and press the Execute Custom Action button. The dialog box (on the right) now displays the status of the execution, which can be InProgess, while it's running, and then Execution Succeeded as shown here when it's finished, with the exit code from the script on the right-hand side.</p> <p></p> <p>As scripts usually produce output from their execution by printing to their standard output stream, the AppControl custom action captures that output stream and displays it on the screen, below the green status line. In this case, it's the message <code>calc_script: arg=hello</code> that was printed by the script.</p>"},{"location":"Getting%20Started/appcontrol_worker/#a-script-with-output-parameters","title":"A script with output parameters","text":"<p>A shell script does not have a notion of output parameters. But in many situations, people write code that produces results, and we want to retrieve those results, either for displaying in the AppControl UI, or for communicating them to Scenario so they can be used by other tasks. </p> <p>This second example, the <code>prod_div</code> action, illustrates this use case with a python script that returns two output parameters, and it explains the particular syntax that's used, in the script's standard output stream, to represent return values so Scenario get use them.</p> <p>The <code>pycalc</code> script (source code here) calls a python function that calculates the product and division of its two operands. If we pick the <code>prod_div</code> action in AppControl, the dialog box will shows us the command line and input arguments (<code>operand1</code>, <code>operand2</code>), and after executing the action, we'll also see the standard output, as before.</p> <p></p> <p>However, in this case, we see that the standard output has a very specific format:</p> <pre><code>&lt;appcontrol&gt;\n    {\n        'Message': 'pycalc: success.',\n        'OutputValues': {\n            'product': 72,\n            'division': 8.0,\n         }\n    }\n&lt;/appcontrol&gt;\n</code></pre> <p>Inside the &lt;appcontrol&gt; tags is an object with json/javascript syntax, that is meant to be interpreted by the AppControl worker:</p> <ul> <li> <p>the <code>Message</code> property holds some text that will be displayed in the Scenario   UI, so it should be some kind of summary or resulting status from the   script's execution.</p> </li> <li> <p>the <code>OutputValues</code> property is a dictionary of the output parameters. It must   match the set of parameters listed in the <code>outputParameters</code> element of the   AppControl map (see Custom action example above), and the values   must be filled in by the script.</p> </li> </ul>"},{"location":"Getting%20Started/appcontrol_worker/#running-scriptscustom-actions-in-scenario","title":"Running scripts/custom actions in Scenario","text":"<p>So far, we've seen how to define our scripts in the AppControl map, and how to run them from the AppControl UI. This section deals with using those scripts inside Scenario.</p> <p>If everything has been set up correctly by your administrator, as described in Pre-requisites above, importing and loading (activating) the map that defines your scripts is enough to make them available in Scenario. The AppControl worker publishes all the custom actions from your map as Scenario tasks, in a namespace called AppControl.</p>"},{"location":"Getting%20Started/appcontrol_worker/#using-the-script-as-a-scenario-task","title":"Using the script as a Scenario task","text":"<p>In the Scenario designer, when creating or modifying a scenario definition, drag and drop an automatic task object (the one with the gears icon, called Task), and select the AppControl namespace in the Task Parameters panel. In the list of tasks, you can see two tasks from the <code>map,v1.xml</code> file, with names:</p> <ul> <li>map,v1@admin__comp_calc</li> <li>map,v1@admin__comp_prod_div</li> </ul> <p>The structure of these names reflects the AppControl artifacts: &lt;map&gt;@&lt;user&gt;__&lt;component&gt;_&lt;action&gt;. These actions are now available, like any other task, to be used in your scenario.</p> <p></p> <p>Select the <code>prod_div</code> task, enter values for operands 1 and 2, and then run the scenario. In the cockpit, you can see the output values and the message, just as we saw in the AppControl UI above:</p> <p></p>"},{"location":"Getting%20Started/appcontrol_worker/dynamicmapinformations/","title":"Dynamic informations","text":"<p>An application, is a set of components defined statically with an xml format (cf: Create an application). Nevertheless, the application can be enriched with dynamic informations. Dynamic informations are returned by the 'check' command.</p> <p>To return dynamic informations the 'check' command should log on the standard output some informations. The informations should respect the following format:</p> <pre><code>&lt;appcontrol&gt; APPCONTROL JSON OBJECT &lt;/appcontrol&gt;\n</code></pre> <p>Dynamic informations can enrich the content of the component owning the 'check'. In dynamic informations start/stop commands are not allowed.</p> <p>The JSON format is the following:</p> <pre><code>{\n    \"link\": \"Hyperlink to wathever you want\", //Optional\n    \"name\": \"Name of the component\",          //Required\n    \"displayName\": \"Display name\",            //Optional\n    \"state\": \"  Initializing | \n                InError |\n                Start |\n                Starting |\n                Started |\n                Stop |\n                Stopping |\n                Stopped \",     //Optional\n    \"parents\":                 //Optional but highly recommanded\n    [\n        \"Parent1\",\n        \"Parent2\",\n    ],\n    \"exitCode\": 256, //Optional\n    \"color\": \"Color of the code RGB format or hexa code ('255,255,255' or #FFFFFF\", //Optional\n    \"Type\": \" Used to display an icon on the map. An url to an image (png, jpeg or svg) can be set. Anyway you can use one of the following value: browser, cd, chip, data-information, devises, dollar, euro, file, green-thermometer, hdd, memflash, memory, middleware, network, orange-thermometer, pounds, process, service, tools, user, yen\",  //Optional\n    \"groupName\": \"Name of the group\",  //Optional\n    \"customActions\": //Optional\n        [\n            {\n            \"visibility\": \"Private\",\n            \"customActionName\": \"echo Action\",\n            \"customActionDescription\":  null,\n            \"customActionCommandLine\": \"echo $(message)\",\n            \"parallelCustomAction\": false,\n            \"parameters\":\n            [\n                {\n                    \"parameterName\":\"message\",\n                    \"description\": \"\",\n                    \"defaultValue\": \"Welcome message\",\n                    \"validationRule\": \"*\",\n                    \"isEditable\": true\n                }\n            ]\n            }\n        ],\n    \"filters\": {\"filter name 1\": [\"filter values\"] ,\n                \"filter name 2\": [\"filter values\"]\n                }  //Optional,\n    \"dynamicTree\" : [\n            {\n                //A json object with the properties defined above\n            }\n    ] //Optional,\n}\n</code></pre> <p>A full example is available in this documentation: - Application Xml - JSON dynamic data</p> <p>The application should be tested this way. </p> <ol> <li>First copy this the link to the application: Application</li> <li>Go to the New Application menu and import the previous application    </li> <li>Once the application is loaded go to the Architecture menu, you should obtain the following rendering:    </li> </ol> <p>On the above screenshot, you can observe that dynamic components are displayed with an 'octagon form' whereas the 'static component' is displayed with a 'square form'.</p>"},{"location":"openfaas/synchronous/","title":"Contents","text":"<p>This document describes how to write a simple, synchronous python function that is run inside OpenFaas, and that can be invoked from XC Scenario to implement a scenario task. It details the integration with OpenFaas and the mechanics of making your function available on the server. A separate document will address the case of an asynchronous function.</p> <p>Note that OpenFaas supports writing functions in many programming languages other than python, please have a look at the official OpenFaas documentation for more information.</p> <p>Part of this document is based on the OpenFaas First Python Function tutorial.</p>"},{"location":"openfaas/synchronous/#openfaas-and-cli-installation","title":"OpenFaas and CLI Installation","text":"<p>This document assumes that you have a working OpenFaas installation, and you will need to provide the URL for it. Contact an administrator if you don't have this information. In our example, we'll be using <code>https://openfaas.xcomponent.com</code> as the url for our OpenFaas server, or gateway.</p> <p>As part of the OpenFaas installation, the <code>faas-cli</code> executable should be in your path. This is OpenFaas' command-line interface (CLI), and it is required to perform a number of tasks, including building and deploying your functions, so a set of valid credentials must be configured for it. Again, if needed, contact the administrator responsible for your OpenFaas installation.</p>"},{"location":"openfaas/synchronous/#write-a-simple-function","title":"Write a simple function","text":""},{"location":"openfaas/synchronous/#initialize-the-work-environment","title":"Initialize the work environment","text":"<p>Create a working directory and move into it. Now scaffold a new Python function using the CLI:</p> <pre><code>faas-cli new --lang python3 pyfunc\n</code></pre> <p>This retrieves a set of templates from GitHub, if needed, then creates the following files:</p> <pre><code>pyfunc/handler.py\npyfunc/requirements.txt\npyfunc.yml\n</code></pre> <p>Again, this example uses python. Have a look at this page to see what other languages are available.</p> <p>Note that for a single language, many templates may be available. The default for python is to use the Classic Watchdog, but the above link lists many others.</p>"},{"location":"openfaas/synchronous/#pyfuncyml","title":"pyfunc.yml","text":"<p>This yaml file specifies your functions, and the OpenFaas gateway to use. The <code>faas-cli new</code> command has already filled in most of this file:</p> <pre><code>version: 1.0\nprovider:\n  name: openfaas\n  gateway: http://127.0.0.1:8080\nfunctions:\n  pyfunc:\n    lang: python3\n    handler: ./pyfunc\n    image: pyfunc:latest\n</code></pre> <p>You only need to change or specify the following items:</p> <ul> <li>the gateway, i.e. the url of your OpenFaas installation</li> <li>the docker image name</li> <li>the <code>com.xcomponent.label</code> property (to be added)</li> </ul> <p>OpenFaas supports running functions from Docker images stored on Docker Hub or in private Docker registries. If you decide to use Docker Hub, as we do in this example, you'll need to include a Docker Hub account as the prefix in the image name (<code>joaomdsc</code> in this case, see below).</p> <p>If you want to use a private registry for your images, this document has information on how to specify the access credentials. </p> <p>XC Scenario defines a label (<code>Demo</code> in our example) that is used to filter the functions that will be made available. That label must be referenced here so that your function can be used in XC Scenario. We'll use the <code>labels.com.xcomponent.label</code> property to specify a value, which has to match whatever value was configured in your installation of XC Scenario. Please contact your X4B/Scenario administrator to find out the right label to use here.</p> <p>After applying these changes, here's what the modified <code>pyfunc.yml</code> file looks like:</p> <pre><code>version: 1.0\nprovider:\n  name: openfaas\n  gateway: https://openfaas.xcomponent.com\nfunctions:\n  pyfunc:\n    lang: python3\n    handler: ./pyfunc\n    image: joaomdsc/pyfunc:latest\n    labels:\n      com.xcomponent.label: Demo\n</code></pre>"},{"location":"openfaas/synchronous/#handlerpy","title":"handler.py","text":"<p>The <code>handler.py</code> file is where the function code will be implemented. It starts out with an almost empty function skeleton:</p> <pre><code>def handle(req):\n    \"\"\"handle a request to the function\n    Args:\n        req (str): request body\n    \"\"\"\n\n    return req\n</code></pre> <p>The function has a single parameter <code>req</code> that will contain the body of the HTTP request through which the function was invoked. The default implementation in the provided template simply returns this string unchanged.</p> <p>For the time being, we'll keep the function as it is, while we go through the process of making the function available and running it from XC Scenario. Later on, we'll see how to declare input and output parameters to communicate with a running scenario instance, when the function is used to implement a scenario task.</p>"},{"location":"openfaas/synchronous/#build-the-function","title":"Build the function","text":"<p>Run the following command to build the function:</p> <pre><code>joao@debian1:~$ faas-cli build -f pyfunc.yml\n</code></pre> <p>Note: OpenFaas builds a docker image for the function, so make sure that <code>docker</code> is deployed on the machine.</p> <p>On successful completion, you should see the following message:</p> <pre><code>Successfully tagged joaomdsc/pyfunc:latest\nImage: joaomdsc/pyfunc:latest built.\n</code></pre> <p>You can check the presence of the docker image:</p> <pre><code>docker images\nREPOSITORY                             TAG                     IMAGE ID            CREATED             SIZE\njoaomdsc/pyfunc                        latest                  e7f810f4455f        23 minutes ago      62.1MB\n</code></pre> <p>Now push the image to DockerHub:</p> <pre><code>joao@debian1:~$ docker push joaomdsc/pyfunc:latest\n</code></pre>"},{"location":"openfaas/synchronous/#deploy-the-function-to-the-openfaas-server","title":"Deploy the function to the OpenFaas server","text":"<p>You can now deploy the function to the OpenFaas server, using the following command:</p> <pre><code>joao@debian1:~$ faas-cli deploy -f pyfunc.yml\nDeploying: pyfunc.\n\nDeployed. 202 Accepted.\nURL: https://openfaas.xcomponent.com/function/pyfunc.openfaas-fn\n</code></pre> <p>Check for the presence of a 202 return code. Also note that it might take a minute or two for your function to be available.</p>"},{"location":"openfaas/synchronous/#test-the-function","title":"Test the function","text":"<p>You can invoke the function through <code>curl</code>, passing in a request body with the <code>-d</code> argument:</p> <pre><code>joao@debian1:~$ curl https://openfaas.xcomponent.com/function/pyfunc -d \"Hello!\"\nHello!\njoao@debian1:~$ \n</code></pre> <p>The text that was passed in is returned by the function. </p> <p>You can invoke the function through <code>faas-cli</code>:</p> <pre><code>joao@debian1:~$ echo -n \"Hello!\" | faas-cli -g https://openfaas.xcomponent.com invoke pyfunc\nHello!\njoao@debian1:~$ \n</code></pre> <p>You can also invoke the function through the OpenFaas portal:</p> <p></p> <p>Click on <code>Request body</code>, enter some text (<code>good morning</code> for example), then press <code>Invoke</code>.</p>"},{"location":"openfaas/synchronous/#use-the-function-in-xc-scenario","title":"Use the function in XC Scenario","text":"<p>Create a new scenario, add a task, and pick the OpenFaas namespace. You should find your new function in the list of tasks on the left (if your function does not appear on the list, the label defined in <code>pyfunc.yml</code> may be incorrect, check with your administrator).</p> <p>Select <code>pyfunc</code> in the list. Note the DefaultInput field (on the right image), enter some text value (<code>Hello, OpenFaas world!</code> in this example):</p> <p></p> <p>Now run the scenario, and check the cockpit. You should see the text you entered displayed in the task output:</p> <p></p>"},{"location":"openfaas/synchronous/#write-a-function-with-multiple-parameters","title":"Write a function with multiple parameters","text":"<p>Let's define a second, more realistic function, with input and output parameters. We'll define a function called <code>pyfunc2</code> that takes two inputs, an integer <code>n</code> and a string <code>txt</code>, and returns two outputs, an integer <code>calc</code> and a string <code>msg</code>.</p> <p>Repeat the above steps to create a new function called <code>pyfunc2</code>, and apply the following changes.</p>"},{"location":"openfaas/synchronous/#new-pyfunc2yml","title":"New pyfunc2.yml","text":"<p>In the yaml file, we apply the same changes as before (gateway, image name prefix) but we also add new labels:</p> <pre><code>version: 1.0\nprovider:\n  name: openfaas\n  gateway: https://openfaas.xcomponent.com\nfunctions:\n  pyfunc2:\n    lang: python3\n    handler: ./pyfunc2\n    image: joaomdsc/pyfunc2:latest\n    labels:\n      com.xcomponent.label: Demo\n      com.xcomponent.inputs.n: Number\n      com.xcomponent.inputs.txt: String\n      com.xcomponent.outputs.calc: Number\n      com.xcomponent.outputs.msg: String\n</code></pre> <p>The <code>com.xcomponent.inputs</code> properties define function inputs, and <code>com.xcomponent.outputs</code> define function outputs. The parameter name is appended to the property name, and the value indicates the parameter's type.</p> <p>All the XC Scenario base types can be used : String, Number, Boolean etc.</p>"},{"location":"openfaas/synchronous/#new-handlerpy","title":"New handler.py","text":"<p>Replace the generated <code>handler.py</code> file with the following content:</p> <pre><code>import json\n\ndef handle(req):\n    \"\"\"handle a request to the function\n    Args:\n        req (str): request body\n    \"\"\"\n\n    # De-serialize json, extract input parameters\n    obj = json.loads(req)\n    n = int(obj['n'])\n    txt = obj['txt']\n\n    # Implement your function here\n    calc = 2*n\n    msg = txt.upper()\n\n    # Return the output parameters\n    result = {\n        'calc': calc,\n        'msg': msg,\n        }\n\n    return json.dumps(result)\n</code></pre> <p>XC Scenario calls the OpenFaas functions with a json request body containing the input parameters. The code de-serializes the json data and extracts the two input parameters.</p> <p>After this step, you can implement whatever processing your function needs to do. In our example, the numeric parameter gets multiplied by 2, and the string parameter is converted to uppercase.</p> <p>The final step in the code is to return a json string encoding the output parameters defined in the yaml file, so that XC Scenario can make them available as task outputs.</p>"},{"location":"openfaas/synchronous/#build-and-deploy-the-new-function","title":"Build and deploy the new function","text":"<p>Repeat the above steps to build the new <code>pyfunc2</code> function, upload its docker image to Docker Hub, and deploy it on the OpenFaas server.</p>"},{"location":"openfaas/synchronous/#test-the-new-function","title":"Test the new function","text":"<p>You can invoke the function from the command line as before; however, passing json strings is cumbersome, as all the double quotes must be escaped, so it's easier to put the input in a json file, let's call it <code>inputs.json</code>:</p> <pre><code>{\n    \"n\": 13,\n    \"txt\": \"hello\"\n}\n</code></pre> <p>The <code>-d</code> option to the <code>curl</code> command supports the <code>@</code> syntax to specify a file name, so the function can be invoke with the following command:</p> <pre><code>joao@debian1:~$ curl https://openfaas.xcomponent.com/function/pyfunc2 -d @inputs.json\n{\"calc\": 26, \"msg\": \"HELLO\"}\njoao@debian1:~$ \n</code></pre> <p>It can also be invoked through the OpenFaas portal as before:</p> <p></p>"},{"location":"openfaas/synchronous/#use-the-new-function-in-xc-scenario","title":"Use the new function in XC Scenario","text":"<p>As before, create a new scenario, add a task, pick the OpenFaas namespace, and select the <code>pyfunc2</code> function. The Task Inputs section shows the two input parameters <code>n</code> and <code>txt</code>:</p> <p></p> <p>Finally, enter some values, then run the scenario and check the cockpit for the function output:</p> <p></p> <p>The output parameters display the results of the OpenFaas' function processing.</p>"}]}